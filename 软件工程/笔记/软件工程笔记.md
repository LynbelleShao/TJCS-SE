# 软件工程

## 第一章 引入

### 小题

##### 软件

**软件**是计算机系统中与硬件相互依存的另一部分，它是包括程序、数据及其相关文档组成的完整集合。

**软件=程序+数据+文档**

**程序**是按事先设计好的功能和性能要求要求执行的指令序列。

**数据**是指程序能正常处理信息的数据和数据结构。

**文档**是与软件开发、设计、运行、维护有关的图文资料。

**程序的形式：**

- 面向机器的程序=二进制代码
- 面向过程的程序=算法+数据结构
- 面向对象的程序=对象+消息
- 面向组件的程序=组件+基础设施

软件具有**复杂度**、**一致性**、**可变性（演化性）**和**不可见性**等固有的内在特性，这是造成软件开发困难的根本原因。

**文档的作用：**记录；交流工具；阶段性成果；便于管理；软件质量保障；参照；便于维护；



##### 软件危机

**软件危机**是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。

两方面问题： 

- 如何开发软件，以满足不断增长、日趋复杂的需求。 （开发）  
- 如何维护数量不断膨胀的软件产品。 （维护）

**几乎所有软件都不同程度的存在这类问题。**

软件工程的出现是为了解决软件危机

编写程序只是软件开发过程中的一个阶段，在典型软件开发工程中，编写程序所需工作量只占软件开发全部工作量的10%~20%

程序只是完整的软件产品的一个组成部分，在软件生命周期的每个阶段都要得出最终产品的一个或几个组成部分(这些组成部分通常以文档资料的形式存在)。也就是说，一个软件产品必须由一个完整的配置组成，软件配置主要包括程序、文档和数据等成分。必须清除只重视程序而忽视软件配置其余成分的错误观念。

软件就是程序是错误的观念

做好软件定义时期的工作，是降低软件成本提高软件质量的关键

维护是极端艰巨复杂的工作，需要花费很大代价。统计数据表明，实际上用于软件维护的费用占软件总费用的55%~70%



##### 软件工程

**软件工程**是采用**工程**的**概念、原理、技术和方法**来**开发与维护**软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以**经济地开发**出高质量的软件并**有效地维护**它，这就是软件工程

许多软件的复杂性主要不是由问题的内在复杂性造成的，而是由必须处理的大量细节造成的

开发软件的目的是支持用户的工作，因此仅仅用正确的方法构造系统还不够，还必须构造出正确的系统

课件上写的是八项基本原则，课本上写的是七条基本原理（前7条）

7条原理是确保软件产品质量和开发效率的原理的最小集合。这7条原理是互相独立的，其中任意六条原理的组合都不能代替另一条原理，因此，它们是缺一不可的最小集合，这7条原理又是相当完备的。

**软件工程的八项基本原则**

1. 用分阶段的生命周期计划严格管理软件工程过程

2. 坚持在软件过程中进行阶段评审

3. 实行严格的产品控制

4. 采用现代的开发技术进行软件的设计与开发

5. 工作结果应当是能够清楚审查的

6. 开发小组的人员应该“少而精”

7. 承认不断改进软件工程实践的必要性

8. 2-8定理

   <img src=".\assets\image-20241019153838563.png" alt="image-20241019153838563" style="zoom:60%;" />

大部分错误时是在编码之前造成的

错误发现与改正的越晚，所需付出的代价就越高

基准配置管理：修改软件要经过评审，获得批准后才能修改

开发小组的人员应该小而精，小是因为随着开发小组人员数目的增加，因为交流情况讨论问题而造成的通信开销急剧增加

遵循前6条基本原理，就能够按照当代软件工程基本原理实现软件的工程化生产，但是仅有前6条，不能保证软件开发与维护的过程能够赶上时代前进的步伐和技术的不断进步



**工程**是将理论和所学的知识应用于实践的科学，以便经济有效的解决实际问题。

**软件工程与计算机科学的区别**：

- 科学→发现世界上已经存在的事物
- 工程→创造世界上从未存在的事物

**软件工程五要素**：人、项目、过程、软件制品、方法工具。

**软件工程的两个主要研究方面**：软件开发技术、软件工程管理。

软件工程包括**技术**和**管理**两方面的内容。

**软件开发环境IDE**是相关的一组软件工具的集合，它支持一定的软件开发方法或按一定的软件开发模型组织而成。

**软件工具**是指支持计算机软件开发、维护、模拟、移植和管理而研制的程序系统。

**计算机辅助软件工程CASE**是一组工具和方法的集合，可以辅助软件开发生命周期各阶段进行软件开发。



##### 软件工程方法学

把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为范型

软件工程方法学包括三要素：方法、工具和过程

目前使用广泛的是传统方法学和面向对象方法学

传统方法学自顶向下，面向对象方法学主动反复迭代



##### 软件生存周期

**软件生存周期**是软件产品或软件系统从设计、开发、投入使用到被淘汰的全过程。

<img src=".\assets\image-20241019153918498.png" alt="image-20241019153918498" style="zoom:30%;" />

**软件工程的三个时期：**

软件生命周期由软件定义、软件开发和运行维护（软件维护）3个时期组成

每个时期又划分成若干个阶段：

软件开发时期分成问题定义、可行性研究和需求分析

开发时期分成总体设计、详细设计、编码和单元测试、综合测试。前2个叫系统设计，后2个叫系统实现

维护时期不再划分阶段

课件：

**软件工程的八个阶段**：①问题定义②可行性分析③需求分析④总体设计⑤详细设计⑥编码实现⑦测试⑧运行和维护



##### **软件过程模型**

瀑布模型是文档驱动

快速原型模型是需求驱动

螺旋模型是风险驱动

###### 瀑布模型

<img src=".\assets\image-20241019151640193.png" alt="image-20241019151640193" style="zoom:30%;" />

顺序性和依赖性

前一阶段的输出文档就是后一阶段的输入文档

需求是已知的，开发过程中需求不变

优点和缺点都在于文档：

没有文档的软件几乎是不可能维护的，瀑布模型是文档驱动模型

涉及过程仅依靠文档，书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户需要

**改进**：

课本：

实际的瀑布模型是带反馈环的

在后面阶段发现前面阶段的错误时，需要沿着反馈线回去修正再回来继续完成后面阶段的任务

课件：

<img src=".\assets\image-20241019151813841.png" alt="image-20241019151813841" style="zoom:30%;" />

适用情况： 需求是已知的，开发过程中需求不变，面向结构



###### **快速原型模型**

**流程**：需求收集→快速设计→反复迭代

原型的用途是获知用户的真正需求，一旦需求确定了，原型将被抛弃

快速原型的本质是“快速”

不带反馈环是这种模型的优点（因为原型系统已经确认需求了），需求驱动，基本上做到线性顺序开发。

问题是用户需求不明确时难以开始。



###### **增量模型**

<img src=".\assets\image-20241019151953310.png" alt="image-20241019151953310" style="zoom:30%;" />

第一个增量往往是**核心产品**，每一个增量均发布一个可操作产品，早期的增量是最终产品的“可拆卸”版本

软件开发早期阶段的投资能够获得明显回报，较易维护，逐步增加产品功能可以使用户有较为充裕的时间学习和适应新产品，减少了全新产品给用户的冲击。

困难是要求软件具有开放的结构，对于增量的依赖关系和项目实际情况需要仔细规划。

某种意义上说，增量模型本身是矛盾的，一方面要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列，每个构件本质上都独立于另一个构件

课本上的风险更大的增量模型：

<img src=".\assets\image-20241207102534415.png" alt="image-20241207102534415" style="zoom:80%;" />

冒着构件无法集成到一起的风险



###### 螺旋模型

原型模型是一种能使某些风险降至最低的方法，但某些类型的风险原型模型是无能为力的。而螺旋模型就是在每个阶段前都增加了风险分析过程的快速原型模型

<img src=".\assets\image-20241019153720298.png" alt="image-20241019153720298" style="zoom:25%;" />

有利于已有软件的重用

减少了过多测试和测试不足带来的风险

风险驱动是优点也是缺点，需要开发人员具有丰富的风险评估经验能够在真正风险到来时发现风险



###### 喷泉模型

<img src=".\assets\image-20241207103921936.png" alt="image-20241207103921936" style="zoom:33%;" />

面向对象软件开发无缝迭代

典型的面向对象的软件工程模型之一

各个阶段之间的迭代或是一个阶段内不同步骤之间的迭代



###### 敏捷模型

敏捷软件开发宣言：

- 个体和交互胜过过程和工具
- 可以工作的软件胜过面面俱到的文档
- 客户合作胜过合同谈判（能够满足客户不断变化的需求）
- 响应变化胜过遵循计划

注意，只是对因素做了比较，一个因素更重要并不是说其他因素不重要，更不是说某个因素可以被其他因素代替



### 大题

##### 软件工程的本质特征

##### 软件工程的基本原理

##### 软件生命周期各阶段

##### 软件过程模型的优缺点 （习题讲解）

##### 结构化范型和面向对象范型的优缺点 （习题讲解）



猜测：

##### 软件过程模型的区别



课件：

##### **软件工程的基本目标**

①较低的开发成本

②按时完成开发任务并及时交付

③实现客户要求的功能

④所开发软件具有良好的性能

⑤较高的可靠性、可扩展性、可移植性

⑥软件维护费用低



##### **软件设计开发的方法**

面向机器编程、结构化方法、面向数据结构方法、面向对象方法、面向构件方法、面向方面、面向agent、面向服务、基于搜索的软件编程开发方法



## **第二章 可行性分析**



### 小题

<img src=".\assets\image-20241019153918498.png" alt="image-20241019153918498" style="zoom:30%;" />

可行性研究的目的不是解决问题，而是确定问题是否值得去解决

可行性研究实质上是要进行一次大大压缩简化了的系统分析与设计的过程，在较高层次上以较抽象的方式进行的系统分析和设计的过程

软件可行性分析是通过对项目的**市场需求、资源供应、建设规模、工艺路线、设备选型、环境影响、资金筹措、盈利能力**等方面的研究，从**技术、经济、工程**等角度对项目进行调查研究和分析比较，并对项目建成以后可能取得的财务、经济效益及社会环境影响进行科学预测，为项目决策提供公正、可靠、科学的软件咨询意见。

可行性分析的目的是用最小的代价在尽可能短的时间内确定问题是否可解，同时确定问题是否值得去解决



### 大题



##### 可行性研究的目的

笔记与习题讲解P35

##### **可行性分析的具体任务**

1. 技术可行性：技术分析、资料分析、风险分析、困难性
2. 经济可行性：成本/效益分析、价值和成本的关系
3. 运营可行性：用户使用可能性、时间进度可行性、组织和人事可行性、文化上的可行性
4. 社会可行性：开发项目是否会在社会上或政治上引起侵权、隐私、破坏或其他责任问题。



##### 可行性研究的一般步骤

见笔记与习题讲解P25

好像去年说了这里不考大题



##### 对具体系统的可行性分析

如果考大题的话，看笔记与习题讲解P35第二题开始



## **第三章 软件需求分析**

### 小题

需求分析分为面向结构分析和面向对象分析

面向结构分析有数据流模型、数据字典和实体关系模型

面向对象分析有对象模型、功能模型和动态模型

<img src=".\assets\image.png" style="zoom:30%;" />

软件需求是利益相关方对目标软件系统的要求和期望。

软件需求分为：功能需求、性能需求、可靠性和可用性需求、约束性需求、出错处理需求、接口需求、逆向需求、将来可能提出的要求

任何一个软件系统本质上都是信息处理系统

访谈是最早开始使用的获取用户需求的技术

数据流图没有任何具体的物理部件，只是描述逻辑过程

数据流图是系统逻辑功能的图形表示，因此是分析员和用户之间极好的通信工具

注意数据流图与流程图的区分，流程图会画出分支循环结构的条件，而数据流图只绘制所有可能的数据流向，不出现数据流的条件

数据流图四种组成成分：源点/终点（矩形）、处理（圆形/圆角矩形）、数据存储（开口矩形）、数据流（箭头）

数据存储和数据流都是数据，仅仅所处的状态不同。数据存储是处于静止状态的数据，数据流是处于运动中的数据。

数据流图和数据字典共同构成系统的逻辑模型，只有数据流图和对数据流图中每个元素的精确定义放到一起，才能共同构成系统的规格说明

数据字典中，由数据元素组成数据的方式有顺序、选择、重复和可选

数据字典由4类元素的定义组成：数据流、数据元素、数据存储和处理（课件上还有源点终点）

数据字典组成数据的符号表示：

![image-20241207150508836](.\assets\image-20241207150508836.png)

E-R图是一种面向问题的数据模型，描述了从用户角度看到的数据，反映了用户的现实环境，与在软件系统中的实现方法无关

E-R图中包含3种相互关联的信息：实体、实体的属性和联系

软件需求是整个软件项目的**终极目标**

软件需求是后续软件开发活动（设计、编码和测试）的**主要基础**

需求可以分为功能需求和非功能需求

- 非功能需求：用简洁、清晰（无歧义）、肯定的自然语言描述
- 功能需求：直观上可表示为输入--输出关系

模型与建模：具体模型→抽象建模

UML包括用例图、状态图、类图、活动图、序列图、协作图、构建图、配置图

面向对象方法学的出发点和基本原则就是模拟人类的思维方式

客观世界中的实体对象叫做问题域中的**对象**，相较于传统数据结构的静态属性，对象既有静态的属性，也有动态的行为

只有同时使用**对象、类、继承和消息**的方法，才是真正的面向对象的方法

面向对象的设计方法与传统的面向过程方法有本质不同，强调模拟现实世界中的概念而不强调算法，计算机的观点是不重要的

对象是封装了数据结构及可以施加在这些数据结构上的操作的封装体

类是对具有相同数据和相同操作的一组相似对象的定义

实例是由某个特定的类所描述的一个具体的对象

消息是要求某个对象执行在定义它的那个类中所定义的某个操作的规格说明



### 大题

##### 对系统的综合要求有哪些

笔记与习题讲解P39

##### 与用户沟通获取需求的方法

笔记与习题讲解P40有4条

再加上课件：需求获取的方法：（1）访谈（2）讲述（3）观点（4）录像机（5）调研问卷（6）网络搜索（7）网上需求社区

高质量的用户需求：（1）真实性（2）一致性（3）精确性（4）无冗余（5）完全性（6）可行性（7）可验证性

##### 数据流图的用途

笔记与习题讲解P31

##### 数据字典的用途

笔记与习题讲解P33

##### 面向对象方法学的定义和优点

![image-20241207170013704](.\assets\image-20241207170013704.png)

##### 对象的特点

（1）以数据为中心

（2）对象是主动的

（3）实现了数据封装

（4）本质上具有并行性

（5）模块独立性好

##### 对象具有封装性的条件

![image-20241207170609687](.\assets\image-20241207170609687.png)

##### **面向结构和面向对象方法的比较**

<img src=".\assets\image-20241020120034581.png" alt="image-20241020120034581" style="zoom:30%;" />

面向结构方法SOA：面向功能，把系统看成一组功能（过程）的集合

面向对象方法OOA：把问题当作一组相互作用的实体，并确定实体间关系

<img src=".\assets\image-20241020120103128.png" alt="image-20241020120103128" style="zoom:33%;" />

<img src=".\assets\image-20241020120130797.png" alt="image-20241020120130797" style="zoom:30%;" />

##### **OOA目的或任务**

分析和定义所有和被求解的问题相关的类及同类关联的关系和行为，为了达到这个目标，必须完成以下任务：

（1）必须在客户和软件工程师之间沟通了解基本的用户需求

（2）必须标识类（定义属性和方法）

（3）必须刻划类层次

（4）表示对象/对象关系（对象连接）

（5）必须建模对象行为

（6）任务（1）-（5）递进的反复使用，直到 分析清楚，完成建模

##### **OOA建立分析模型的5个基本原则**

（1）建模信息域

（2）描述模块功能

（3）表示模型行为

（4）分解以模型显示更多细节

（5）早期模型表示问题的本质，而后期模型提供实现细节

##### 面向对象建模技术的三种模型

要会背模型对应的图

- 功能模型：描述处理(数据变换)，指明系统应“做什么”

  定义：表示软件系统的功能性质，指明系统应“做什么”，因此更直接的反映用户对目标系统的需求

  数据流图，用例图

- 对象模型：描述静态结构, 定义做事情的实体

  定义：表示静态的、结构化的系统的数据性质。它是对模拟客观世界实体的对象以及对象间彼此关系的映射，描述了系统的静态结构

  类图

- 动态模型：描述交互过程, 规定什么时候做何事

  定义：表示瞬时的、行为化的系统的控制性质，规定了对象模型中对象的合法变化序列

  顺序图和状态图

  动态模型以“事件”（Events）和“状态”（States）为其模型的主要概念

对象模型是最基本最重要的，为其他两种模型奠定了基础

### 设计题

#### 系统流程图

基本符号：

<img src=".\assets\image-20241207124958934.png" alt="image-20241207124958934" style="zoom:80%;" />

系统符号：

<img src=".\assets\image-20241207142915009.png" alt="image-20241207142915009" style="zoom:80%;" />

==**例题：**==

<img src=".\assets\微信图片_20241207142948.jpg" style="zoom:80%;" />



#### **数据流图DFD**

<img src=".\assets\image-20241207144137380.png" alt="image-20241207144137380" style="zoom:60%;" />

如果源点和终点是同一个，为了方便绘图可以画两个同样的符号分别表示源点和终点

==**例题：**==

##### **简单数据流图**

根据题目描述，**逐句**绘制即可。

**（1）机票预订系统**

<img src=".\assets\image1.png" style="zoom:50%;" />

<img src=".\assets\image-20241220194706625.png" alt="image-20241220194706625" style="zoom:70%;" />

[【UML】如何画好数据流图基础教程_数据流图怎么画-CSDN博客](https://blog.csdn.net/qq_46874327/article/details/127161166?ops_request_misc=%7B%22request%5Fid%22%3A%22A69BC0F0-E7A4-4603-9CD5-EBE7B04DD52C%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=A69BC0F0-E7A4-4603-9CD5-EBE7B04DD52C&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-127161166-null-null.142^v100^pc_search_result_base7&utm_term=数据流图画法&spm=1018.2226.3001.4187)

**（2）旅行社预订机票系统**

<img src=".\assets\image-20241020114731127.png" alt="image-20241020114731127" style="zoom:30%;" />

<img src=".\assets\image2.png" style="zoom:50%;" />

**（3）银行取款系统**

<img src=".\assets\image-20241020114846141.png" alt="image-20241020114846141" style="zoom:33%;" />

<img src=".\assets\image-20241020114905012.png" alt="image-20241020114905012" style="zoom:33%;" />

**（4）售书系统**

<img src=".\assets\image-20241020114928042.png" alt="image-20241020114928042" style="zoom:30%;" />

**（5）患者监护系统**

![image-20241207151145489](.\assets\image-20241207151145489.png)

<img src=".\assets\image-20241207151234861.png" alt="image-20241207151234861" style="zoom:50%;" />

**（6）银行储蓄系统**

![image-20241207161254182](.\assets\image-20241207161254182.png)<img src=".\assets\image-20241207161309905.png" alt="image-20241207161309905" style="zoom:50%;" />



##### **分层数据流图**

在数据流图中应该描绘**所有可能的数据流向**，比如审核一份表格后分出合格和不合格，则这两种状态的数据都应该画出其流向。而**不应该描绘出现某个数据流的条件**。即在数据流图中不应该出现if，每个数据流都应该是一个具体的事物。数据流图的基本要点是描绘“做什么”而不考虑“怎样做”。（出错处理也是忽略的）

**数据存储和数据流都是数据，仅仅所处的状态不同。**数据存储是处于静止状态的数据，数据流是处于运动中的数据。**需要数据存储的情况是对于一个数据的流出和流入有时间差**，则需要先存储流出的数据，等到需要该数据流入其他处理时再从存储中取出。

**任何改变数据的操作都是处理。**

**顶层数据流图只含一个加工表示整个系统。这个“系统”一般就是标题名称。**

**（1）考务处理系统**

<img src=".\assets\image-20241020115025405.png" alt="image-20241020115025405" style="zoom:33%;" />

**0层：**

<img src=".\assets\image3.png" style="zoom:50%;" />

0层的唯一“加工“就是标题：考务处理系统，也是每句描述的主语

注意“不合格报名单”和“不合格成绩单”要原路打回

**1层：**

<img src=".\assets\image-20241020115136703.png" alt="image-20241020115136703" style="zoom:33%;" />

把加工细分成了登记报名单和统计成绩，其实这两个名字在细分时可能无法得出，能得到的是会将考务处理系统划分成报名单和成绩单两个部分，可以先画数据流，画完再决定处理的名字，注意要是动词或者动词+名词的形式。

注意：考生通知单是来自2，不要习惯性的画到1上（因为指向的考生会在左边）

至于“考生名册”为什么会存储起来，请看第2层

**2层：**

<img src=".\assets\image-20241020115200568.png" alt="image-20241020115200568" style="zoom:23%;" />

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20241020115221751.png" alt="image-20241020115221751" style="zoom:22%;" />

注意题干描述两点：

一是“指定考生通知单（含成绩及合格/不合格标志）”，说明在“制作通知单”这个处理当中，要用到“考生名册”，所以在“登记考生”处得到的考生名册需要存储起来。

二是“成绩分类统计和试题难度分析”，注意这是两张表，成绩分类统计需要用到成绩存储表和考生存储表，试题难度分析只需要成绩存储表。

**（2）工厂订单报表**

[软件工程 -- 数据流图的画法_数据流图怎么画-CSDN博客](https://blog.csdn.net/I_r_o_n_M_a_n/article/details/121309525)

![](.\assets\image5.png)

**0层：**

<img src=".\assets\image-20241020115342673.png" alt="image-20241020115342673" style="zoom:50%;" />

这道题目的顶层数据流非常少啊

**1层：**

<img src=".\assets\image-20241020115401591.png" alt="image-20241020115401591" style="zoom:50%;" />

**产生报表和处理事务这两个处理在时间上明显不匹配**：每当有一个事务发生时立即处理它，然而每天只产生一次订货报表，因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储（存储着订货报表的数据，每当订货报表的数据有更新时，可以立即获取最新的订货报表的数据，这样就可以实现每当有一个事务发生时立即处理它）。

并不是所有数据存储和数据流都能直接从问题描述中提取出来。例如，“当某种零件的库存数量少于库存量临界值时就应该再次订货”，这个事实意味着必须在某个地方有零件库存量和库存量临界值这样的数据。因此创建了仓库清单这个存储空间，相当于在里面提取当前库存量和库存临界值到处理事务中，从而得出是否需要订货。也因此发现“处理事务”这个加工还可以细分，展示出上述的比较从而得出是否补货结论的过程。

**2层：**

<img src=".\assets\image-20241020115426323.png" alt="image-20241020115426323" style="zoom:50%;" />



考虑通过系统的逻辑数据流，当发生一个事务时必须首先接收它；随后按照事务的内容修改库存清单；最后如果更新后的库存量少于库存量临界值时，则应该再次定货，也就是需要处理定货信息。因此，把“处理事务”这个功能分解为下述3个步骤：“接收事务”、“更新库存清单”和“处理订货”，这在逻辑上是合理的。我们为什么不进一步分解“产生报表”这个功能呢？因为订货报表中需要的数据在存储的订货信息中全都有，产生报表只不过是按一定顺序排列这些信息，再按一定格式打印出来。然而这些考虑纯属具体实现的细节，不应该在数据流图中表现。同样道理，对“接收事务”或“更新库存清单”等功能也没有必要进一步细化。总之，**当进一步分解将涉及如何具体地实现一个功能时，就不应该再分解了**。**划分的是步骤而不是细节。**

#### **数据字典DD**

**数据字典**是对所有与系统相关的数据元素的一个有组织的列表，以及精确的、严格的定义，使得用户和系统分析员对于输入、输出、存储成分和中间计算结果等有共同的理解。

**词条描述**：

- 数据流：对应DFD中的数据流，是箭头上的内容

  <img src=".\assets\image-20241020115552589.png" alt="image-20241020115552589" style="zoom:33%;" />

- 数据元素：

  <img src=".\assets\image-20241020115606787.png" alt="image-20241020115606787" style="zoom: 33%;" />

- 数据文件：对应的是DFD的数据存储

  <img src=".\assets\image-20241020115626277.png" alt="image-20241020115626277" style="zoom:33%;" />

- 加工逻辑：对应的是DFD的处理，加工编号就是圆口矩形上部的编号，加工逻辑说明描述的是基本加工如何把输入数据流变换为输出数据流的加工规则

  <img src=".\assets\image-20241020115641979.png" alt="image-20241020115641979" style="zoom:33%;" />

- 源点及汇（终）点：对应DFD的源点终点

  <img src=".\assets\image-20241020115713462.png" alt="image-20241020115713462" style="zoom:33%;" />

**数据结构的描述**

<img src=".\assets\image-20241020115741661.png" alt="image-20241020115741661" style="zoom:40%;" />

重复的意思是可以有多个，m和n的意思是数量在m和n之间

连接符1..9意思是数据范围是1到9

数据结构描述会出现在各个词条描述当中

<img src=".\assets\image-20241020115817017.png" alt="image-20241020115817017" style="zoom:40%;" />

==**例题：**==

（1）工厂订单报表

<img src=".\assets\image-20241207150144063.png" alt="image-20241207150144063" style="zoom:80%;" />

数据字典卡片：

<img src=".\assets\image-20241207150208482.png" alt="image-20241207150208482" style="zoom:80%;" />

（2）电话号码

<img src=".\assets\image-20241207151003920.png" alt="image-20241207151003920" style="zoom:80%;" />

**DD的实现**

（1）人工方法

（2）自动方法（利用字典管理程序）

**DD应该具有的特点**

（1）通过名字可方便查阅数据定义

（2）无冗余

（3）易更新修改

#### **实体关系模型E-R**

**实体关系图**是数据库概念设计的最常用工具。

实体联系图的基本成分：

<img src=".\assets\image-20241020115848582.png" alt="image-20241020115848582" style="zoom:50%;" />

==**例题：**==

（1）银行储蓄系统

<img src=".\assets\image-20241207161254182.png" style="zoom:80%;" />

<img src=".\assets\image-20241207161418083.png" alt="image-20241207161418083" style="zoom:80%;" />

**（2）机票预订系统**

![image-20241207161622020](.\assets\image-20241207161622020.png)

<img src=".\assets\image-20241207161651612.png" alt="image-20241207161651612" style="zoom:50%;" />

**（3）患者监护系统**

![image-20241207161718416](.\assets\image-20241207161718416.png)

<img src=".\assets\image-20241207161740507.png" alt="image-20241207161740507" style="zoom:80%;" />

**任务**：收集用户需求，将用户非形式化、原始、朴素的需求陈述转化为完整的需求定义，再转化为相应的形式化（计算机化）的需求规格化说明

**名称**：用户需求、软件需求、系统需求



#### UML

**UML定义：**Unified Modeling Language 统一建模语言是一种定义良好、易于表达、功能强大且普遍适用的可视化建模语言。它融入了软件工程领域的新思想、新方法和新技术。它的作用域不限于支持面向对象的分析与设计，还支持从需求分析开始的软件开发的全过程。在系统分析阶段，我们一般用 UML 来画很多图，主要包括用例图、状态图、类图、活动图、序列图、协作图、构建图、配置图等等，要画哪些图要根据具体情况而定。其实简单的理解，也是个人的理解， UML的作用就是用很多图从静态和动态方面来全面描述我们将要开发的系统。

**UML的九种图：**

<img src=".\assets\image-20241020120357262.png" alt="image-20241020120357262" style="zoom:40%;" />

红色为本课程主讲

<img src=".\assets\image-20241020151641592.png" alt="image-20241020151641592" style="zoom:80%;" />

##### **用例图**

Use Case Diagram

用例图是**从用户角度**描述系统功能，是**用户所能观察到**的系统功能的模型图，用例是系统中的一个功能单元。

用例图列出**系统中的用例**和**系统外的参与者**，并显示哪个参与者参与了哪个用例的执行（或称为发起了哪个用例）。

节点：

- 参与者(Actor)

  在系统外部与系统直接交互的**人或事物**（如另一个计算机系统或一些可运行的进程）

  - 参与者**是角色(role)而不是具体的人**，它代表了参与者在与系统打交道的过程中所扮演的角色。所以在系统的实际运作中，**一个实际用户可能对应系统的多个参与者。不同的用户也可以只对应于一个参与者，从而代表同一参与者的不同实例。**
  - **参与者作为外部用户(而不是内部)与系统发生交互作用**，是它的主要特征。 
  - 在后面的顺序图等中出现的“参与者”，与此概念相同，但具体指代的含义，视具体情况而定。

- 用例(Use Case)

  系统外部可见的一个系统功能单元。系统的功能由系统单元所提供，并通过一系列系统单元与一个或多个参与者之间交换的消息所表达 。

边：（注意表格的最左一列，是谁与谁之间的关系）

<img src=".\assets\image-20241020130308240.png" alt="image-20241020130308240" style="zoom:50%;" />

注意，包含的箭头指向的被包含的一方，是小的一方；扩展的箭头指向的是被扩展的一方，是大的一方

参与者类似DFD的外部实体

include是必选，extend是可选

Include: 由用例A连向用例B，表示A使用了B的功能(use) 

Extend: 由用例A连向用例B，表示B描述了基本要求，A描述了特殊要求，A是一种扩展

代表系统的方框的边线表示系统的边界

系统被看作是一个提供用例的黑盒子，内部如何工作、用例如何实现，这些对于用例图都是不重要的

用例是可以被外部实体感受到的一类完整的功能

==**例题：**==

（1）自动售货机

<img src=".\assets\image-20241207182111635.png" alt="image-20241207182111635" style="zoom:50%;" />

<img src=".\assets\image-20241207184005966.png" alt="image-20241207184005966" style="zoom:50%;" />

对于用例之间的关系：“售散装饮料”比普通售货需要额外的动作，所以“售散装饮料”是“售货”的扩展，“供货”和“取货款”都包含“打开机器”和“关闭机器”的动作

（2）订货系统

![](.\assets\image5.png)

<img src=".\assets\image-20241207185440563.png" alt="image-20241207185440563" style="zoom:50%;" />

##### 类图

Class Diagram

类图以反映类的组成(属性、操作)，以及类之间的关系为主要目的，描述了软件系统的**静态结构**，是一种**静态建模方法** 

类图不仅定义系统中的类，还要表示类之间的联系如关联、 依赖、聚合等，也包括类的内部结构(类的属性和操作)。 

类图是**以类为中心**来组织的，类图中的其他元素或属于某个类或与类相关联。 

类图中的“类”与面向对象语言中的“类”的概念是对应的， 是对现实世界中的事物（对象）的抽象。

术语：从上到下分为三部分，分别是类名、属性和操作。 

- 类名是必须有的。

- 类如果有属性，则每一个属性都必须有一个名字，另外还可以有其它的描述信息，如可见性、数据类型、缺省值等。

- 类如果有操作，则每一个操作也都有一个名字，其它可选的信息包括可见性、参数的名字、参数类型、参数缺省值和操作的返回值的类型等。

可见性： - 代表private； + 代表public； # 代表protected； 也可以使用图形表示。（如果未声明可见性则表示尚未定义，没有默认的可见性）

斜体为抽象，抽象类，抽象属性或者抽象操作。抽象类是不能被实例化的类，一般至少包含一个抽象操作。

模版类是一种参数化的类，在编译时把模版参数绑定到不同的数据类型，从而产生不同的类。

接口是一组操作的集合，只有操作的声明而没有实现。用图形表示接口时，与类的区别在于第一行的左侧接口有一个圈和小线。

<img src=".\assets\image-20241020140552017.png" alt="image-20241020140552017" style="zoom:80%;" />

关系：

- 关联关系：描述了类的结构之间的关系。具有方向、名字、角色和多重性等信息。

  - 一般关联：连线上标注关系的名字，类的旁边标注类的角色。用**实线箭头**表示，单边箭头表示单向关联，双向关联省略箭头。多重性 （用数字和⁎表示） 1…⁎：1个或多个 。

  - 聚合关系：Aggregation特殊关联关系，指明一个聚集（整体）和组成部分之间的关系，用**空心菱形箭头**表示。

  - 组合关系：Composition 语义更强的聚合，**部分和整体具有相同的生命周期**，用**实心菱形箭头**表示。

    代码表现为Dialog的属性有Button和TextBox的对象。

    <img src=".\assets\image-20241020142853908.png" alt="image-20241020142853908" style="zoom:30%;" /> Dialog没有了，Button和TextBox也就没有了，生命周期相同。

- 泛化关系：在面向对象中一般称为继承关系，存在于父类与子类、父接口与子接口之间。用**空心三角形实线箭头**表示。箭头方向由子类指向父类。

  代码表现为，A是父类，B是子类，class B : public A，B继承了A

- 实现关系：对应于类和接口之间的关系。用**空心三角形虚线箭头**表示。（课本上叫细化关系，B指向A，就是B细化了A，A细化成了B，B是在A的基础上更详细的描述）

  在C++语言里，使用抽象类代替接口， 使用泛化关系代替实现关系。

  <img src=".\assets\image-20241020143140510.png" alt="image-20241020143140510" style="zoom:50%;" />

- 依赖关系：描述了一个类的变化对依赖于它的类产生影响的情况。例如绑定(bind)、友元(friend)等，用**虚线箭头**表示。

  <img src=".\assets\image-20241020143330348.png" alt="image-20241020143330348" style="zoom:67%;" />

图标汇总：

<img src=".\assets\image-20241020142629109.png" style="zoom:50%;" />

==**例题：**==

（1）图形编辑器

图形编辑器一般都具有一些基本图形，如直线、矩形等，用户可以直接使用基本图形画图，也可以把基本图形组合在一起创建复杂图形。如果区别对待基本图形和组合图形，会使代码变得复杂，而且多数情况下用户认为二者是一样的。组合模式可以用相同的方式处理两种图形。

<img src=".\assets\image-20241020143633152.png" alt="image-20241020143633152" style="zoom:80%;" />

（2）演出售票系统

<img src=".\assets\image-20241207163422846.png" alt="image-20241207163422846" style="zoom:80%;" />

（3）订货系统

![](.\assets\image5.png)

<img src=".\assets\image-20241207185241037.png" alt="image-20241207185241037" style="zoom:50%;" />



##### 对象图

Object Diagram 

略讲。

对象图是**类图的实例**，几乎使用与类图完全相同的标识。它们的不同点在于**对象图显示类的多个对象实例，而不是实际的类**。

<img src=".\assets\image-20241020143910364.png" alt="image-20241020143910364" style="zoom:50%;" />

##### 顺序图

Sequence Diagram

顺序图用来表示**用例中的行为顺序**。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或状态机中引起转换的事件。 

顺序图展示对象之间的交互，这些交互是指在场景或用例的事件流中发生的。顺序图属于**动态建模**。 

顺序图的重点在**消息序列**上，也就是说，描述**消息是如何在对象间发送和接收**的。表示了**对象之间传送消息的时间顺序**。 

浏览顺序图的方法是：**从上到下查看对象间交换的消息**。箭头以时间顺序在图中从上到下排列。

术语：

<img src=".\assets\image-20241020144259875.png" alt="image-20241020144259875" style="zoom:80%;" />

生命线上的窄长方框用以强调这个部分**处于活动状态**。

向哪个对象发消息，实际上就是调用它的类中的操作。所以传递的消息就是箭头指向的对象所在类的一个操作。

比如：信息亭发Request (count, performance)消息给售票中心，表示调用售票中心类的Request (count, performance)操作，来查询演出的信息。 售票中心发Show Available(seat-list)消息给信息亭，表示调用信息亭类中的Show Available(seat-list)操作，给出可用的座位表。

==**例题：**==

（1）银行储蓄系统

![image-20241207190011366](.\assets\image-20241207190011366.png)

<img src=".\assets\image-20241207185934833.png" alt="image-20241207185934833" style="zoom:50%;" />

##### 协作图

collaboration diagram

协作图是一种交互图，强调的是发送和接收消息的对象之间的组织结构，使用协作图来说明系统的**动态情况**。 

协作图主要描述协作对象间的交互和链接，显示对象、对象间的链接以及对象间如何发送消息。 协作图可以表示类操作的实现。

<img src=".\assets\image-20241020150048415.png" alt="image-20241020150048415" style="zoom:80%;" />

协作图和顺序图都表示出了对象间的交互作用，但是它们侧重点不同。 

- 顺序图清楚地表示了交互作用中的**时间顺序(强调时间)**，但没有明确表示对象间的关系。 

- 协作图清楚地表示了对象间的**关系(强调空间)**，但时间顺序必须从顺序号获得。 

协作图和顺序图可以相互转化。

##### 状态图

Statechart Diagram

说明对象在它的生命期中响应事件所经历的状态序列，以及它们对那些事件的响应。 

状态图用于揭示Actor、类、子系统和组件的复杂特性。 

为**实时系统建模**。

组成：

- 状态：对象的状态是指在这个对象的生命期中的一个条件或状况，在此期间对象将满足某些条件、执行某些活动，或等待某些事件。 
- 转移：是由一种状态到另一种状态的迁移。这种转移由被建模实体内部或外部事件触发。 对一个类来说，转移通常是调用了一个可以引起状态发生重要变化的操作的结果。

术语：

<img src=".\assets\image-20241020150538316.png" alt="image-20241020150538316" style="zoom:80%;" />

状态的可选活动表：

<img src=".\assets\image-20241020150559595.png" alt="image-20241020150559595" style="zoom:80%;" />

==**例题：**==

（1）订票机

<img src=".\assets\image-20241020150810255.png" alt="image-20241020150810255" style="zoom:50%;" />

（2）电话系统

![image-20241207180649668](.\assets\image-20241207180649668.png)

![image-20241207180712271](.\assets\image-20241207180712271.png)

<img src=".\assets\image-20241207181924219.png" alt="image-20241207181924219" style="zoom:50%;" />

:star2:状态图是**一个对象**的状态，顺序图是**多个对象之间**

##### 活动图

Activity Diagram

描述系统的**动态行为**。 

包含活动状态(ActionState)，活动状态是指业务用例的一个执行步骤或一个操作，不是普通对象的状态。 

活动图适合描述在**没有外部事件触发的情况下的系统内部的逻辑执行过程**；否则，状态图更容易描述。 

类似于**传统意义上的流程图**。 

活动图主要用于：业务建模时，用于详述业务用例，描述一项业务的执行过程；设计时，描述操 作的流程。

<img src=".\assets\image-20241020151013485.png" alt="image-20241020151013485" style="zoom:80%;" />

##### 构件图

component diagram

构件图用于**静态建模**，是表示构件类型的组织以及各种构件之间依赖关系的图。 构件图通过对构件间依赖关系的描述来估计对系统构件的修改给系统可能带来的影响。

组件图显示软件组件之间的依赖关系。一般来说，软件组件就是一个实际文件，可以是源代码文件、二进制代码文件和可执行文件等。可以用来显示编译、链接或执行时构件之间的依赖关系

<img src=".\assets\image-20241020151232917.png" alt="image-20241020151232917" style="zoom:80%;" />

==**例题：**==

<img src=".\assets\image-20241020151251908.png" alt="image-20241020151251908" style="zoom:50%;" />

##### 部署图

deployment diagram

部署图用于**静态建模**，是表示运行时过程节点结构、构件实例及其对象结构的图。 如果含有依赖关系的构件实例放置在不同节点上，部署视图可以展示出执行过程中的瓶颈。 部署图的两种表现形式：实例层部署图和描述层部署图(会在后面的实例中给出)。

<img src=".\assets\image-20241020151401365.png" alt="image-20241020151401365" style="zoom:80%;" />

==**例题：**==

<img src=".\assets\image-20241020151606947.png" alt="image-20241020151606947" style="zoom:50%;" />



## 第四章 结构设计

### 小题

软件设计是把软件需求变换成为软件的具体解决方案。将用户要求转换为一个具体的设计方案，即决定系统 “怎样做”。

软件设计：总体设计，详细设计。

(1)总体设计/概要设计：确定软件的结构以及各组成成分(子系统或模块)之间的相互关系。 

(2)详细设计：确定模块内部的算法和数据结构，产生描述各模块程序过程的详细文档。

软件解决方案表示为软件设计模型。

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118163641629.png" alt="image-20241118163641629" style="zoom:33%;" />

总体设计过程分成系统设计阶段和结构设计阶段

结构设计确定程序由哪些模块组成，以及这些模块之间的关系；过程设计确定每个模块的处理过程。结构设计是总体设计阶段的任务，过程设计是详细设计阶段的任务。

模块化的依据：E是复杂度，E(P1+P2)>E(P1)+E(P2)这个不等式导致“各个击破”的结论，把复杂的问题分解成许多容易解决的小问题，原来的问题就容易解决了。但是注意，虽然随着不断分解，开发软件的工作量会越来越小，但设计模块间接口所需要的工作量会越来越大

<img src=".\assets\image-20241209101648469.png" alt="image-20241209101648469" style="zoom: 50%;" />

模块设计原理包括：模块化、抽象、信息隐蔽、模块独立、（课本上还有一个逐步求精）

##### 模块设计原理

###### 模块化

软件工程意义上的模块化：把程序划分成若干个模块，每个模块完成一个子功能，把这些模块的组成一个整体，可以完成整个软件系统指定的功能，从而满足用户的需求，这个过程称模块化。

模块化的好处：

- 降低复杂性
- 促进变革
- 作为独立单元易于理解
- 重复使用现有模块
- 每个部分都可以由单独的人进行操作
- 个人软件工程师可以专攻
- 并行开发使实施更容易

<img src=".\assets\image-20241209102058790.png" alt="image-20241209102058790" style="zoom: 80%;" />

###### 抽象

考虑问题时，集中考虑和当前问题有关的主要方面，而忽略和当前问题无关的方面，这就是抽象。

或者说抽象就是抽出事物的本质特性，而暂时不考虑它们的细节。

**软件工程过程的每一步，都是对软件解法的抽象层次的一次细化。**在可行性研究阶段，软件被看作是一个完整的系统部分；在需求分析期间，我们使用在问题环境中熟悉的术语来描述软件的解法；当我们由总体设计阶段转入详细设计阶段时，抽象的程度进一步减少；最后，当源程序写出来时， 也就达到了**抽象的最低层**。

<img src=".\assets\image-20241209102358913.png" alt="image-20241209102358913" style="zoom:80%;" />

###### 逐步求精

逐步求精是为了能集中精力解决主要问题而尽量推迟对问题细节的考虑

Miller法则：一个人在任何时候都只能把注意力集中在（7±2）个知识块上

可以把逐步求精看作是一项把一个时期内必须解决的种种问题按优先级排序的技术。逐步求精方法确保每个问题都将被解决，而且每个问题都将在适当的时候被解决，但是，在任何时候一个人都不需要同时处理7个以上知识块。

**抽象与求精是一对互补的概念**。抽象使得设计者能够说明过程和数据，同时却忽略了低层细节。事实上，可以把**抽象看作是一种通过忽略多余的细节同时强调有关的细节**，而实现逐步求精的方法。求精则帮助设计者**在设计过程中逐步揭示出低层细节**。这两个概念都有助于设计者在设计演化过程中创造出完整的设计模型。

###### 信息隐蔽

信息隐蔽是指，每个模块的**实现细节（不是一切信息，而是实现细节）**对于其它模块来说是隐蔽的。也就是说，**模块中所包含的信息（包括数据和过程）不允许其它不需要这些信息的模块使用**。

局部化有助于实现信息隐蔽，局部化是指把一些关系密切的软件元素物理地放得彼此靠近

###### 模块独立

模块独立是模块化、抽象、信息隐蔽和局部化的直接结果

模块独立是指开发具有独立功能而且和其它模块之间没有过多的相互作用的模块。 

模块独立性, 是指软件系统中每个模块只涉及软件要求的具体的子功能, 而和软件系统中其它的模块的接口是简单的 例如, 若一个模块只具有单一的功能且与其它模块没有太多的联系, 则称此模块具有模块独立性。

好处：一是模块化软件容易开发，二是独立的软件易于测试和维护

模块的独立程度衡量标准是**内聚和耦合**。

模块独立程度的衡量标准：

- 耦合性：对一个软件结构内**不同模块间**互连程度的度量。 

  耦合程度由好到坏：

  - 无直接耦合：如果两个模块之间没有直接关系， 它们之间的联系完全是通过**主模块**的控制和调用来实现的，这就是非直接耦合。这 种耦合的模块独立性最强。

  - 数据耦合：一模块调用另一模块时，被调用模块的输入、输出都是简单的**数据**(若干参数)。 属松散耦合。（仅传参）

  - 控制耦合：一模块向下属模块传递的信息 (开关量、标志等控制被调用模块决策的变量) **控制了被调用模块的内部逻辑**。（传递的参数控制分支）

    去除模块间控制耦合的方法： ①将被调用模块内的判定上移到调用模块中进行 ②被调用模块分解成若干单一功能模块

  - 公共耦合(公共数据区耦合)： 一组模块引用同一个**公用数据区** (也称全局数据区、公共数据环境)。 公共数据区指：全局数据结构、共享通讯区、内存公共覆盖区等

    公共耦合存在的问题 ①软件可理解性降低 ②诊断错误困难 ③软件可维护性差 ④软件可靠性差 (公共数据区及全程变量无保护措施) 慎用公共数据区和全程变量!!!

  - 内容耦合：一模块直接访问另一模块的**内部信息** (程序代码或数据）、模块代码重叠、多入口模块。是最不好的耦合形式。

  目标：建立模块间耦合度尽可能松散的系统 

  **尽量使用数据耦合 少用控制耦合 限制公共耦合的范围 坚决避免使用内容耦合**

  系统中至少必须存在数据耦合，因为只有当某些模块的输出作为另一些模块的输入时系统才能完成有价值的功能

  如果被调用的模块需要使用作为参数传递进来的数据结构中的所有元素，那么把整个数据结构作为参数传递就是完全正确的。但是当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了**特征耦合**。在这种情况下，被调用的模块可以使用的数据多于它确实需要的数据，这将**导致对数据的访问失去控制**，从而给计算机犯罪提供了机会

- 内聚性：标志**一个模块内**各个处理元素彼此结合的紧密程度，理想的内聚模块只做一件事情。 

  内聚程度由弱到强，模块独立性逐级升高：

  - 偶然内聚(巧合内聚)：模块内各部分间无联系。

    缺点：可理解性差， 可修改性差

  - 逻辑内聚：把类似功能的语句（逻辑上相似的功能），组合在一模块内，每次调用由控制模块的参数确定执行哪种具体功能。

    缺点：增强了耦合程度(控制耦合) 不易修改，效率低

  - 时间内聚(经典内聚)：模块完成的功能在同一时间内执行，这些功能只因时间因素关联在一起。

  - 过程内聚(顺序性组合)：模块内各处理成分有数据依赖顺序关系，必须以特定先后次序执行。

  - 通信内聚：模块内各部分使用相同的输入数据，或产生相同的输出结果。

  - 功能内聚：模块仅包括为完成某个功能所必须的所有成分。 (模块所有成分共同完成一个功能，缺一不可 ) **功能内聚是最高程度的内聚**

  目标：建立各个模块完成独立功能的高效和专一系统 

  **优先使用功能内聚 尽量满足过程内聚（顺序内聚） 少用逻辑内聚 坚决避免偶然内聚**

模块独立性比较强的模块应是**高内聚 ,  低耦合**的模块。

内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。

##### 模块设计启发式规则

:star2:启发式规则多数是经验规律律，对改进设计， 提高软件质量，往往有重要的参考价值；但是，**它们既不是设计的目标也不是设计时应该普遍遵循的原理**。

软件结构的度量和术语：

- 深度：表示控制的层数。 
- 宽度：表示控制（同一层次）总跨度。 
- 扇出数：指由一模块直接控制的其他模块的数目。 
- 扇入数：指有多少个模块直接控制一个给定的模块。 
- 上级模块 
- 下级模块

<img src=".\assets\image-20241119102421711.png" alt="image-20241119102421711" style="zoom:33%;" />

1. 改进软件结构提高模块独立性

   力求降低耦合提高内聚。模块的划分要符合独立性原则。

   一个模块的规模过大，可理解程度迅速下降。要进一步分解，分解后不应该降低模块独立性。

   过小的模块，开销过大；模块数目过多将使系统接口复杂。

2. 软件结构的特性参数要适当

   深度能粗略表示软件的复杂程度。 

   宽度越大系统越复杂，对宽度影响最大因素是模块的扇出。宽度太大可增加深度来减少。 

   扇出越大模块越复杂。 

   扇入太大会增加模块接口数，违背模块独立性原则。 

   观察大量软件系统后发现，设计得很好的软件结构通常顶层扇出较多，中层扇出较少，底层扇入到公共的实用模块中去（底层模块有高扇入）。

   <img src=".\assets\image-20241119102804244.png" alt="image-20241119102804244" style="zoom:23%;" />

3. 模块的作用域应该在控制域之内

   模块的作用域：是指受该模块判定影响的所有模块数。 

   模块的控制域：是受这个模块**直接或间接**控制调用的模块数。 

   模块的控制范围：本身及其所有下级模块。 （图中看出）

   模块的作用范围：即直接调用的模块。（图中看不出）

   <img src=".\assets\image-20241119103501510.png" alt="image-20241119103501510" style="zoom: 33%;" />

   <img src=".\assets\image-20241119103514430.png" alt="image-20241119103514430" style="zoom: 33%;" />

4. 力争降低模块接口的复杂程度

   <img src=".\assets\image-20241119103557356.png" alt="image-20241119103557356" style="zoom:33%;" />

5. 设计单入口单出口的模块

   该规则是说模块接口尽量要单入口、单出口，这样可避免出现模块的内容耦合，降低接口成本。 

   当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。 

   结构化程序设计极力主张。

6. 模块功能应该可以预测

   模块的功能应该能够预测，但也要防止模块功能过分局限。 

   如果说一个模块可以当做一个黑盒子，也就是说， 只要输入的数据相同就产生同样的输出，这个模块的功能就是可能预测的。

模式与风格：

- 体系结构风格(Architecture Styles) 表示软件系统的一种特别的基本结构，以及相关的构造方法 
- 设计模式(Design Patterns) 构造型模式、结构型模式、行为型模式 
- 框架(Framework) 另一种研究和构造软件体系结构的方法，更多的是关于应用领域问题的已建立的系统结构。

公认的、被多次使用的系统结构被称为**结构风格、设计模式、(设计)框架**。 

如果说一门工程技术的成熟表现在其基本设计构件的提出和系统化，那么体系结构的风格、模式、框架就是**软件工程中的基本构件**。

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118170215463.png" alt="image-20241118170215463" style="zoom:33%;" />

**软件设计方法**有：

- 结构化设计方法(SD) 就是基于数据流的设计方法
- 面向对象的设计方法(OOD) 
- 面向数据结构的设计方法(JSD方法)

**软件体系结构：**

- 定义软件局部和总体计算部件的构成。 从整体看，软件体系结构是由结构和功能各异、相互作用的部件集合，按照层次构成的。 
- 定义组成部件之间的相互作用关系。 
- 定义构成系统的合成原理、方法、原则 
- 定义构成系统应该遵守的约束的条件。

### 大题

##### 为每种类型的耦合和内聚举例子

10-24作业

笔记与习题讲解P74



### 设计题

##### 基于数据流的设计方法

原理：

<img src=".\assets\image-20241209110302905.png" alt="image-20241209110302905" style="zoom:33%;" />

变换原理：

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118184737352.png" alt="image-20241118184737352" style="zoom:30%;" />

步骤： 

最顶层的控制模块C~m~协调下述从属的控制功能： 

（1）**输入信息处理控制模块C~i~**，协调对所有输入数据的接收； 

（2）**变换中心控制模块C~t~**，管理对内部形式的数据的所有操作； 

（3）**输出信息控制模块C~o~**，协调输出信息的产生过程。

==例题：==

（1）汽车数字仪表板的设计

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118185040018.png" alt="image-20241118185040018" style="zoom: 40%;" />

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118185056225.png" alt="image-20241118185056225" style="zoom: 50%;" />

确定输入流和输出流的边界，从而孤立出变换中心：

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118185159404.png" alt="image-20241118185159404" style="zoom: 50%;" />

第一级分解的结果：

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118185235317.png" alt="image-20241118185235317" style="zoom:33%;" />

第二级分解的结果：

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118185255250.png" alt="image-20241118185255250" style="zoom: 50%;" />

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118215208446.png" alt="image-20241118215208446" style="zoom: 50%;" />

最后得到精化的数字仪表板系统的软件结构

<img src="E:\11111111日常\课程\计算机系统结构\系统结构笔记\assets\image-20241118215253590.png" alt="image-20241118215253590" style="zoom: 50%;" />

（2）用户命令交互子系统

<img src=".\assets\image-20241118220956269.png" alt="image-20241118220956269" style="zoom:40%;" />

<img src=".\assets\image-20241118221016611.png" alt="image-20241118221016611" style="zoom:40%;" />

（3）

<img src=".\assets\image-20241209111559156.png" alt="image-20241209111559156" style="zoom:50%;" />

10-24作业

笔记与习题讲解P74



##### 面向对象的设计方法

由类图导出总体结构

？

举例：

ATM系统

<img src=".\assets\image-20241118221126900.png" alt="image-20241118221126900" style="zoom:40%;" />



##### 面向数据结构的设计方法

jackson图

在课本P145，但是没讲



## 第五章 详细设计

前一章介绍了软件的总体设计，本章将在总体设计的基础上进行详细的展开、精确的描述。

详细设计阶段的根本目标：如何实现所要求的系统，也即要对目标系统进行精确描述，为编码阶段的程序书写做准备。

详细设计阶段的任务还**不是具体地编写程序**，而是要设计出程序的“蓝图”，程序员根据这个蓝图写出实际的程序代码。因此，详细设计时应该考虑程序代码的质量。即衡量程序的质量不仅要看它的逻辑是否正确，性能是否满足要求，更主要的是要看它是否容易阅读和理解。

- 软件定义阶段定义了问题结构，叫作软件设计的**一级蓝图**。 可用系统流程图表示、或数据流图表示、或用结构化语言表示、或以形式化软件设计语言表示。 
- 软件总体设计确定了软件结构，即确定模块的划分、模块间的接口。可称作软件设计**二级蓝图**。用结构图、Jackson结构图、Warnier图来表示、或用HIPO图来表示。 
- 软件详细设计（也称软件算法设计、软件过程设计、软件逻辑设计）确定每个软件模块的实现算法，可称软件设计的**三级蓝图**。可用程序流程图描述、或用伪码描述。



### 设计题

##### 详细设计工具

注意，这些图的==课本习题==在“笔记与习题讲解"P104

###### 程序流程图

也称为程序框图，程序流程图使用三种基本控制结构是: 顺序、选择、循环。

<img src=".\assets\image-20241209112858653.png" alt="image-20241209112858653" style="zoom:80%;" />

流程图的优点： 

直观、简单、易学、普及 

流程图的主要缺点： 

- 流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。 
- 流程图中用箭头代表控制流，因此程序员不受任何约束， 可以完全不顾结构程序设计的精神，随意转移控制。 
- 流程图不易表示数据结构。

###### N-S盒图

N-S Diagram

研制盒图的目的是：既要制定一种图形工具， 又不允许它违反结构化原则。 

<img src=".\assets\image-20241209113009547.png" alt="image-20241209113009547" style="zoom:80%;" />

<img src=".\assets\image-20241119144049110.png" alt="image-20241119144049110" style="zoom:33%;" /> <img src=".\assets\image-20241119144105584.png" alt="image-20241119144105584" style="zoom:28%;" />

盒图具有以下特点： 

- 功能域（即某一具体构造的功能范围）有明确的规定，并且很直观地从图形表示中看出来； 
- 想随意分支或转移是不可能的； 
- 局部数据和全程数据的作用域可以很容易确定； 
- 容易表示出递归结构。

###### PAD图

Problem Analysis Diagram

<img src=".\assets\image-20241119144247746.png" alt="image-20241119144247746" style="zoom:33%;" />

<img src=".\assets\image-20241119144340261.png" alt="image-20241119144340261" style="zoom:33%;" />

<img src=".\assets\image-20241119144417625.png" alt="image-20241119144417625" style="zoom:25%;" /> <img src=".\assets\image-20241119144434946.png" alt="image-20241119144434946" style="zoom:25%;" />

PAD图的特点：

- 使用表示结构化控制结构的PAD符号所设计出的程序**必然是结构化程序**。 
- PAD图所描述的程序结构十分清晰，图中最左面的竖线是程序的主线，即第一层结构，随着程序层次的增加，PAD图逐渐向右延伸，每增加一个层次， 图形向右扩展一条竖线，**PAD图中的竖线的总条数就是程序的层次数**。
- PAD是二维树层次结构、**自顶向下、自左到右**遍历所有节点，易读、易记、易懂。
- 既可用于表示程序逻辑，也可用于描述数据结构。 
- PAD描述的算法易译为高级程序语言。 
- PAD图的符号具有支持自顶向下、逐步求精方法的作用。开始时设计者可以定义一个抽象的程序，随着设计工作的深入而用def符号逐步增加细节，直至完成详细设计。

###### 判断表

组成：

1. 左上部列出所有条件； 
2. 左下部是所有可能做的动作； 
3. 右上部为各种可能组合条件，其中每一列表示一种可能组合； 
4. 右下部的每一列是和每一种条件组合所对应的应做的工作。

==**例题：**==

（1）右上角的条件没有重合的，比较简单

<img src=".\assets\image-20241119144817574.png" alt="image-20241119144817574" style="zoom: 50%;" />

（2）更复杂一点

![image-20241209214641488](.\assets\image-20241209214641488.png)

对于右上角规则表，解释如下：

1：行李重量小于30，无论乘客是什么类型，都一样

2：头等舱的国内乘客，每公斤4元

3：其他舱的国内乘客，每公斤6元

4：头等舱的国内残疾乘客，4/2

5：其他舱的国内残疾乘客，6/2

6-9与2-5相比，都是2倍（国外乘客的每种情况与国内乘客分别对应）

<img src=".\assets\image-20241209214709254.png" alt="image-20241209214709254" style="zoom:70%;" />

优点：简洁 无歧义 类似卡若图 

缺点： 不能表示顺序和重复的处理特性。

###### 判定树

判定树是判定表的变种，形式简单易懂，更容易表示层次结构关系。但不如判定表简洁，重复次数多。

<img src=".\assets\image-20241119144907777.png" alt="image-20241119144907777" style="zoom:33%;" />

<img src=".\assets\image-20241119144952407.png" alt="image-20241119144952407" style="zoom:33%;" />

<img src=".\assets\image-20241119145004182.png" alt="image-20241119145004182" style="zoom:33%;" />

###### PDL

(Program Design Language)

分支选择嵌套程序的编程实现方式：

- 多重嵌套
- 条件逻辑组合（与或非）

PDL是一种用于描述功能模块的算法设计和加工细节的语言。称为设计程序用语言。伪码语言。 

伪码的语法规则分为“外语法”和“内语法”。 

PDL具有严格的关键字外语法，用于定义控制结构和数据结构，同时它的表示实际操作和条件的内语法可使用自然语言的词汇。

<img src=".\assets\image-20241119145547174.png" alt="image-20241119145547174" style="zoom:50%;" />

PDL语言特点：

- PDL虽然不是程序设计语言，但是它与高级程序设计语言非常类似，只要对PDL描述稍加变换就可变成源程序代码 。因此，它是详细设计阶段很受欢迎的表达工具。 
- 用PDL写出的程序，既可以很抽象，又可以很具体。因此，容易实现自顶向下逐步求精的设计原则。 
- PDL描述同自然语言很接近，易于理解。 
- PDL描述可以直接作为注释插在源程序中，成为程序的内部文档。这对提高程序的可读性是非常有益的。 
- PDL一种半结构化的描述，与程序结构相似，因此自动产生程序比较容易。 

PDL的缺点是不如图形描述形象直观，因此人们常常将PDL 描述与一种图形描述结合起来使用。

## 第六章  编码

通常把**编码**和**测试**统称为**实现**

编码是把软件设计结果转换成程序设计语言书写的程序的过程。

编码是对设计的进一步具体化

编码之前的一项重要工作是选择一种适当的程序设计语言

### 编码阶段的两个重要决策

#### 编程语言的选择

编程语言的分类：机器语言、汇编语言、高级语言

第四代编程语言：高级语言+用户界面+数据库

程序开发环境应该具备的特性：

- 通用性：适用于不同的语言、不同的应用领域和开发方法； 
- 适应性：通过开关设置，能配制出不同需要的程序设计支撑环境实例； 
- 开放性：能方便地增加新工具； 
- 支持复用：能支持可复用模块的存储、索引和查找； 
- 自控性：保证自身操作的正确与协调； 
- 自带数据库：提供数据库机制，存储、管理已开发的软件产品； 
- 保证质量：有助于提高所开发软件的质量； 
- 吸引用户：用户愿意使用； 
- 具有市场竞争力：能真正提高软件生产力。

#### 编码标准和风格

原因：

- 使程序员进行“无私程序设计” 
- 避免程序员与其产生的代码之间的关系过于密切 
- 多个程序员写的代码如同一个人所写  
- 不是追求“程序美的地方” 
- 提高程序代码的规范化程度 
- 使程序代码易读、易懂、易修改，重用 
- 实现程序员之间相互进行程序测试和维护

编码风格的具体体现 

1. 标识符（符号名、变量名）的风格 

   实际意义，精炼，名字唯一

2. 注释的风格 

   注释决不是可有可无的

   一些正规的程序文本中，注释行的数量占到整个源程序的1/3到1/2，甚至更多

   注释分为序言性注释和功能性注释

   - **序言性注释：**通常置于每个程序模块的开头部分，给出程序的整体说明，对于理解程序本身具有引导作用。
   - **功能性注释：**嵌在源程序体中，用以描述其后的语句或程序段是在做什么工作，或是执行了下面的语句会怎么样。而不要解释下面怎么做。

3. 数据说明的风格 

   - 数据说明的次序应当规范化 ：

   <img src=".\assets\image-20241119215948561.png" alt="image-20241119215948561" style="zoom:33%;" />

   - 说明语句中变量安排有序化：当多个变量名在一个说明语句中说明时，应当对这些变量按字母的顺序排列。

   - 使用注释说明复杂数据结构

4. 语句结构的风格  

   - 在一行内只写一条语句：

     在一行内只写一条语句，并且采取适当的移行和缩进格式，使程序的逻辑、层次和功能变得更加明确。 

     许多程序设计语言允许在一行内写多个语句。但这种方式会使程序可读性变差。因而不可取。

   - 程序编写首先应当考虑清晰性

   - 程序要能直截了当地说明程序员的用意

   - 除非对效率有特殊的要求,  程序编写要做到清晰第一，效率第二。

   - 首先要保证程序正确

   - 避免使用临时变量而使可读性下降

   - 让编译程序做简单的优化

   - 尽可能使用库函数

   - 避免不必要的转移

     避免使用GOTO语句绕来绕去

   - 避免使用空的else

   - 避免采用过于复杂的条件测试 

   - 尽量减少使用“否定”条件语句

   - 尽可能用通俗易懂的伪码来描述程序的流程，然后再翻译成必须使用的语言

   - 尽量单入口单出口

   - 要模块化，使模块功能尽可能单一化，模块间的耦合能够清晰可见

   - 利用信息隐蔽，确保每一个模块的独立性

   - 从数据出发去构造程序

   - 不要修补不好的程序，要重新编写。也不要一味地追求代码的复用，要重新组织。

   - 对太大的程序，要分块编写、测试，然后再集成。

   - 对递归定义的数据结构尽量使用递归过程

5. 输入／输出的风格 

   不论是批处理的输入／输出方式，还是交互式的输入／输出方式，在设计和编码时都应考虑下列原则：

   - 对所有的输入数据都要进行检验，识别错误的输入，以保证每个数据的有效性 
   - 检查输入项的各种重要组合的合理性，必要时报告输入状态信息 
   - 使得输入的步骤和操作尽可能简单，并保持简单的输入格式 
   - 输入数据时，应允许使用自由格式输入 
   - 应允许缺省值 
   - 输入一批数据时，最好使用输入结束标志，而不要由用户指定输入数据数目 
   - 在交互式输入输入时，要在屏幕上使用提示符明确提示交互输入的请求，指明可使用选择项的种类和取值范围。同时，在数据输入的过程中和输入结束时，也要在屏幕上给出状态信息
   - 当程序设计语言对输入／输出格式有严格要求时，应保持输入格式与输入语句的要求的一致性
   - 给所有的输出加注解，并设计输出报表格式。 输入／输出风格还受到许多其它因素的影响。如输入／输出设备（例如终端的类型，图形设备，数字化转换设备等）、用户的熟练程度、以及通信环境等。

6. 程序layout风格

   视觉组织、 空格、空行和移行

   恰当地利用空格，可以突出运算的优先性，避免发生运算的错误。

   程序段之间可用空行隔开。

### 程序复杂性

减少程序复杂性，可提高软件的简单性和可理解性，软件开发费用减少，开发周期缩短，软件内部潜藏错误减少。跟测试标准有直接关系。

#### 复杂性度量方法

1. 代码行度量法 
2. McCabe度量法 
3. Halstead的软科学法

##### McCabe度量法 

又称环路复杂性度量，是一种基于程序控制流的复杂性度量方法。

它基于一个程序模块的程序图中环路的个数，因此计算它时，首先要画出程序图。

程序图是退化的程序流程图。流程图中每个处理都退化成一个结点，流线变成连接不同结点的有向弧 。程序图仅描述程序内部的控制流程，完全不表现对数据的具体操作，以及分支和循环的具体条件。

计算环路复杂性的方法：根据图论，在一个强连通的有向图G中，环的个数由以下公式给出： V(G)＝m－n＋p 其中，V(G)是图G中环路个数，m 是图G中弧数， n 是图G中结点数，p 是图G中的强连通分量个数。（强连通分量是在这个分量里所有节点两两可达）

**来自网络：**

<img src=".\assets\image-20241209223511639.png" alt="image-20241209223511639" style="zoom: 80%;" />

**来自课本：**

<img src=".\assets\image-20241209223537781.png" alt="image-20241209223537781" style="zoom:80%;" />

为使图成为强连通图，从图的入口点到出口点加一条用虚线表示的有向边（从终点指向起点），使图成为强连通图。这样就可以使用上式计算环路复杂性。

下图示例，结点数n＝11，弧数m＝13（虚线也算），p＝1，则有 V(G)＝m－n＋p＝13－11＋1＝3

:star2:就用课件公式就好了 **V(G)＝m－n＋p**，用虚线连首尾，这样m就会多了1，p肯定是1，强连通图的极大连通子图是1。

V(G)等于程序图中弧所封闭的区域数。等于程序图中线性无关的圆圈数。

<img src=".\assets\image-20241119233033945.png" alt="image-20241119233033945" style="zoom:33%;" />

环路复杂度取决于程序控制结构的复杂度。当程序的分支数目或循环数目增加时其复杂度也增加。环路复杂度与程 序中覆盖的路径条数有关。 

环路复杂度是可加的。例如，模块A的复杂度为3，模块B 的复杂度为 4，则模块A与模块B的复杂度是7。

McCabe建议，对于复杂度超过10的程序，应分成几个小程序，以减少程序中的错误。Walsh用实例证实了这个建议的正确性。在McCabe复杂度为10的附近，存在出错率的间断跃变。 

McCabe环路复杂度隐含的前提是：错误与程序的判定加上例行子程序的调用数目成正比。加工复杂性、数据结构、 录入与打乱输入卡片的错误可以忽略不计。

缺点 

- 对于不同种类的控制流的复杂性不能区分 
- 简单IF语句与循环语句的复杂性同等看待 
- 嵌套IF语句与简单CASE语句的复杂性是一样的 
- 模块间接口当成一个简单分支一样处理 
- 一个具有1000行的顺序程序与1 行语句的复杂性相同

##### Halstead软科学法

采用一组基本的度量值，对程序复杂性进行度量。

这组度量值通常在程序产生之后得出，或者在设计完成之后估算出。

 N1为实际出现的**运算符总次数**，N2为实际出现的**操作数总次数**

n1为**不同运算符的个数**，n2为**不同操作数的个数**

Halstead程序长度N定义为: N = N1 + N2

Halstead程序长度的预测值：H=n1log~2~n1 + n2log~2~n2

<img src=".\assets\image-20241120001511550.png" alt="image-20241120001511550" style="zoom:40%;" />

<img src=".\assets\image-20241120001531103.png" alt="image-20241120001531103" style="zoom:33%;" />

<img src=".\assets\image-20241120001548088.png" alt="image-20241120001548088" style="zoom:33%;" />

<img src=".\assets\image-20241120001822758.png" alt="image-20241120001822758" style="zoom:33%;" />

​                      预测的Halstead长度与实际的Halstead长度是非常接近的。

Halstead长度的作用：

- 分析程序的潜在错误数

- 预测程序中的错误

  <img src=".\assets\image-20241120001905763.png" alt="image-20241120001905763" style="zoom:33%;" />

Halstead度量的缺点：

- 不区别自己编的程序与别人编的程序差异，这是与实际经验相违背的。这时应将外部调用乘上一个大于1的的常数 Kf (应在1～5之间，它与文档资料的清晰度有关)。 
- 没有考虑非执行语句。补救办法：在统计n1、n2、N1、N2 时，可以把非执行语句中出现的运算对象，运算符统计在内。
- 在允许混合运算的语言中，每种运算符与它的运算对象相关 。 
- 如果一种语言有整型、实型、双精度型三种不同类型的运算对象，则任何一种基本算术运算符(＋、－、×、／)实际上代表了6种运算符。在计算时应考虑这种因数据类型而引起差异的情况。 
- 忽视了嵌套结构 (嵌套的循环语句、嵌套IF语句、括号结构等)。一般地，运算符的嵌套序列，总比具有相同数量的运算符和运算对象的非嵌套序列要复杂得多。解决的办法是对嵌套结果乘上一个嵌套因子

## 第七章 软件测试 

### 小题

##### 定义

软件测试在软件生命周期中横跨两个阶段。通常在编写出每个模块之后就对它做必要的测试(称为**单元测试**)，**模块的编写者和测试者是同一个人**，编码和单元测试属于软件生命周期的同一个阶段。在这个阶段结束之后，对软件系统还应该进行各种**综合测试**，这是软件生命周期中的另一个独立的阶段，通常由**专门的测试人员**承担这项工作。



##### 判断题

定义：软件测试是为了发现错误而运行一个软件的过程

测试是为了发现程序中的错误而执行程序的过程 

一个好的测试用例是发现了至今未发现错误的用例 

一次成功的测试是发现了至今未发现错误的测试 

程序测试能证明错误的存在, 但不能证明错误不存在。 

测试只能证明程序中有错误，不能证明程序中没有错误。但是，精心的设计测试方案，有可能充分覆盖程序逻辑并使程序达到所要求的可靠性

测试的目的是发现程序中的错误，为了证明程序有错, **而不是证明程序无错**。

把证明程序无错当作测试目的不仅是不正确的, 完全做不到的，而且对做好测试没有任何益处，甚至是十分有害的。 （因为以证明程序正确为目标，就会设计一些不易暴露错误的测试方案，只有以发现错误为目标，才会力求设计出最能暴露错误的方案）

软件测试要设法使软件发生故障, 暴露软件错误。 

测试的“成功”与“失败” ：能够发现错误的测试是成功的测试，否则是失败的测试。

“测试的目的是说明程序正确地执行它应有的功能” 这种说法不正确

测试绝不能证明程序是正确的

为了达到最佳的测试效果，应该由独立的第三方从事测试工作。

软件设计的最小单元是模块



##### 有效vs验证

软件测试是用于确保软件符合其规范并满足用户需求的过程

- Validation有效： 
  - “Are we building the right product?”
  - 软件需要实现用户需要的功能
  - 客观
- Verification验证：
  - “Are we building the product right?”
  - 软件应符合规范
  - 主观



##### 程序测试vs软件测试

软件测试不同于程序测试; 

软件测试应贯穿于软件定义与开发的整个期间； 

据美国一家公司统计，查出的软件错误中，属于需求分析和软件设计的错误约占 64%，属于程序编写的错误仅占 36%。程序编写的许多错误是“先天的 ”



##### 测试方法

<img src=".\assets\image-20241204081435980.png" alt="image-20241204081435980" style="zoom:33%;" />

- 静态测试

  基本特征是在对软件进行**分析、检查和审阅**，**不实际运行被测试的软件**

  对需求规格说明书、软件设计说明书、源程序做检查和审阅

- 动态测试

  通过**运行被测程序**来检验软件的动态行为和运行结果的正确性

  两个基本要素：

  - 被测试程序
  - 测试数据（测试用例）

  两种方法：

  - 黑盒测试：把程序看作一个黑盒子,**完全不考虑程序的内部结构和处理过程**。也就是说,黑盒测试是在**程序接口进行的测试**,它只检查程序功能是否能按照规格说明书的规定正常使用,程序是否能适当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息(例如数据库或文件)的完整性。黑盒测试又称为**功能测试**
  - 白盒测试：白盒测试法与黑盒测试法相反,它的前提是可以把程序看成装在一个透明的白盒子里,**测试者完全知道程序的结构和处理算法**。这种方法**按照程序内部的逻辑测试程序**,检测程序中的主要执行通路是否都能按预定要求正确工作。白盒测试又称为**结构测试**

测试用例的重要性：

- 指导人们系统地进行测试
- 有效发现缺陷，提高测试效率
- 作为评估和检验的度量标准
- 积累和传递测试的经验与知识

测试用例设计要求：

- 具有代表性和典型性
- 寻求系统设计和功能设计的弱点
- 既有正确输入也有错误或异常输入
- 考虑用户实际的诸多使用场景

举例：纸杯测试<img src=".\assets\image-20241204082146820.png" alt="image-20241204082146820" style="zoom:33%;" />



##### 自动软件测试

手动软件测试和生成测试报告很耗时
每次更改后都必须重复软件测试（回归测试）
编写可以自动运行的测试驱动程序



##### 软件调试

<img src=".\assets\image-20241204155733150.png" alt="image-20241204155733150" style="zoom:30%;" />

软件调试是在进行了成功的测试之后才开始的工作

调试的任务是进一步诊断和改正程序中潜在的错误 

调试活动由两部分组成：性质原因和位置,修改排除这个错误 

调试工作是一个具有很强技巧性和经验性的工作 

调试是通过现象，找出原因的一个思维分析的过程 

通过debuger工具来进行

调试方法：

- 强行排错法

  <img src=".\assets\image-20241204155947051.png" alt="image-20241204155947051" style="zoom: 50%;" />

- 回溯法调试

  <img src=".\assets\image-20241204160006747.png" alt="image-20241204160006747" style="zoom:50%;" />

  但是随着程序规模的扩大，应该回溯的路径数目也变得越来越大，以致彻底回溯变成完全不可能了

- 归纳法调试

  <img src=".\assets\image-20241204160026735.png" alt="image-20241204160026735" style="zoom:50%;" />

- 演绎法调试

  <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20241204160043813.png" alt="image-20241204160043813" style="zoom:50%;" />

- 对分查找法

  <img src=".\assets\image-20241216111222613.png" alt="image-20241216111222613" style="zoom:50%;" />

对分查找法、归纳法和演绎法都属于原因排除法



大题

##### 软件测试原则

(1)所有测试都应该能追溯到用户需求。正如上一小节讲过的,软件测试的目标是发现错误。从用户的角度看,最严重的错误是导致程序不能满足用户需求的那些错误。

(2)应该远在测试开始之前就制定出测试计划。实际上,一旦完成了需求模型就可以着手制定测试计划,在建立了设计模型之后就可以立即开始设计详细的测试方案。因此,在编码之前就可以对所有测试工作进行计划和设计。
(3)把Pareto原理应用到软件测试中。Pareto原理说明,测试发现的错误中的80%很可能是由程序中20%的模块造成的。当然,问题是怎样找出这些可疑的模块并彻底地测试它们。
(4)应该从“小规模”测试开始,并逐步进行“大规模”测试。通常,首先重点测试单个程序模块,然后把测试重点转向在集成的模块簇中寻找错误,最后在整个系统中寻找错误。
(5)穷举测试是不可能的。所谓穷举测试就是把程序所有可能的执行路径都检查一遍的测试。即使是一个中等规模的程序,其执行路径的排列数也十分庞大,由于受时间、人力以及其他资源的限制,在测试过程中不可能执行每个可能的路径。因此,测试只能证明程序中有错误,不能证明程序中没有错误。但是,精心地设计测试方案,有可能充分覆盖程序逻辑并使程序达到所要求的可靠性。
(6)为了达到最佳的测试效果,应该由独立的第三方从事测试工作。所谓“最佳效果"是指有最大可能性发现错误的测试。由于前面已经讲过的原因,开发软件的软件工程师并不是完成全部测试工作的最佳人选(通常他们主要承担模块测试工作)。

<img src=".\assets\image-20241204081143772.png" alt="image-20241204081143772" style="zoom:30%;" />

### 设计题

#### 白盒测试

内部测试、开盒测试、结构测试、玻璃盒测试、基于覆盖的测试

根据被测程序的逻辑结构设计测试用例，力求提高测试覆盖率

##### 语句覆盖

含义：选择足够多的测试数据，使被测程序中**每个语句**至少执行一次

缺点：

- 语句覆盖对程序的逻辑覆盖很少（没有分别测试判定表达式中每个条件值取不同值时的情况）
- 很弱的逻辑覆盖标准

##### 判定覆盖

又叫分支覆盖

含义：不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次，也就是**每个判定的每个分支**都至少执行一次

缺点：

- 判定覆盖比语句覆盖强，但是对程序逻辑的覆盖程度仍然不高（只是走完了每个分支，没有走完每一种排列组合）

##### 条件覆盖

含义：不仅每个语句至少执行一次，而且使**判定表达式中的每个条件**都取到各种可能的结果

<img src=".\assets\image-20241204083756602.png" alt="image-20241204083756602" style="zoom: 50%;" />

<img src=".\assets\image-20241204083909544.png" alt="image-20241204083909544" style="zoom:33%;" />

<img src=".\assets\image-20241204083932466.png" alt="image-20241204083932466" style="zoom:33%;" />

条件覆盖不一定包含判定覆盖，判定覆盖也不一定包含条件覆盖。

##### 判定/条件覆盖

含义：选取足够多的测试数据，使得判定表达式中的**每个条件都取到各种可能的值（条件覆盖）**，而且**每个判定表达式也都取到各种可能的结果（判定覆盖）**

![image-20241204084406438](.\assets\image-20241204084406438.png)

##### 条件组合覆盖

含义：选取足够多的测试数据，使得**每个判定表达式中条件的各种可能组合**都至少出现一次

注意，是一个判定表达式中的所有组合，不是所有出现过的条件的全部组合（拿例子说就是不是ABX的所有组合，而是AB和AX的所有组合）

<img src=".\assets\image-20241204084905975.png" alt="image-20241204084905975" style="zoom: 67%;" />

<img src=".\assets\image-20241204084924261.png" alt="image-20241204084924261" style="zoom:50%;" />

<img src=".\assets\image-20241204084952579.png" alt="image-20241204084952579" style="zoom:50%;" />

满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到，例如上述4组测试数据都没有测试到路径sacbd

满足条件组合覆盖标准的测试数据，也一定满足判定覆盖、条件覆盖和判定/条件覆盖标准。因此，条件组合覆盖是前述几种覆盖标准中最强的

##### 路径覆盖

含义：选取足够多的测试数据，使数据的**每条可能路径**都至少执行一次（如果程序图中有环，则要求每个环至少经过一次）

<img src=".\assets\image-20241204090802019.png" alt="image-20241204090802019" style="zoom:33%;" />

路径覆盖+条件组合覆盖是强测试

##### 点覆盖

等价于语句覆盖

![image-20241204090951417](.\assets\image-20241204090951417.png)

##### 边覆盖

等价于判定覆盖

![image-20241204091004213](.\assets\image-20241204091004213.png)

#### 黑盒测试

又称输入/输出测试、外部测试、功能测试、数据驱动测试、基于规格说明书的测试

黑盒测试的特点：

- 力图发现下述类型的错误：
  - 功能不正确或遗漏了功能
  - 界面错误
  - 数据结构错误或外部数据库访问错误
  - 性能错误
  - 初始化错误和终止错误
- 在软件测试的后期阶段进行黑盒测试
- 易于实施
- 易于理解

黑盒测试方法：

##### 等价类划分法

等价类：

等价类：输入域(问题域)的一个子集，**在该子集中，各个输入数据对于揭示程序中的错误都是等效的**。即：以等价类中的某代表值进行的测试，等价于对该类中其它取值的测试

有效等价类：指那些对于软件的规格说明书而言，是合理的、有意义的输入数据所构成的集合。（用于**实现功能和性能**的测试）

无效等价类：指那些对于软件的规格说明书而言，是不合理的、无意义的输入数据所构成的集合。（用于测试那些**所实现的功能和性能不符合规格说明书的要求**）

划分等价类的经验规则：

(1)如果输入条件规定了取值范围，可定义一个有效等价类和两个无效等价类

<img src=".\assets\image-20241204093400812.png" alt="image-20241204093400812" style="zoom:50%;" />

(2)如果输入条件代表集合的某个元素，则可定义一个有效等价类和一个无效等价类

(3)如规定了输入数据的一组值，且程序对不同输入值做不同处理，则每个允许的输入值是一个有效等价类，并有一个无效等价类(所有不允许的输入值的集合

<img src=".\assets\image-20241204093418270.png" alt="image-20241204093418270" style="zoom:50%;" />

(4)如果规定了输入数据必须遵循的规则，可确定一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则)

 (5)如已划分的等价类各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类

例题1：

<img src=".\assets\image-20241204093709630.png" alt="image-20241204093709630" style="zoom:50%;" />

<img src=".\assets\image-20241204093723588.png" alt="image-20241204093723588" style="zoom:50%;" />

<img src=".\assets\image-20241204093738762.png" alt="image-20241204093738762" style="zoom:50%;" />

为每一个无效等价类分别设计一个测试用例

注意测试用例不要出现相同的

<img src=".\assets\image-20241204093752944.png" alt="image-20241204093752944" style="zoom:50%;" />

例题2：

<img src=".\assets\image-20241204093818430.png" alt="image-20241204093818430" style="zoom:50%;" />

例题3：课本189页

##### 边界测试

![image-20241204100219759](.\assets\image-20241204100219759.png)

<img src=".\assets\image-20241204100327965.png" alt="image-20241204100327965" style="zoom:30%;" />

边界测试不是从某等价类中随便挑一个作为代表，而是每个边界都要作为测试条件

测试边界上的合法数据,以及刚超过边界的非法数据

越界测试通常简单地加1或1个单位；减1或1个单位

<img src=".\assets\image-20241204100553680.png" alt="image-20241204100553680" style="zoom:40%;" />

##### 错误推测法

根据经验、直觉和预感来进行测试

##### 因果图法

因果图适合于描述对于多种输入条件的组合，相应产生多个动作的形式来设计测试用例。

因果图方法最终生成的是判定表。

<img src=".\assets\image-20241204100744008.png" alt="image-20241204100744008" style="zoom:33%;" />

例题：

<img src=".\assets\image-20241204100940950.png" alt="image-20241204100940950" style="zoom:40%;" />

<img src=".\assets\image-20241204100956507.png" alt="image-20241204100956507" style="zoom:33%;" />

<img src=".\assets\image-20241204101011422.png" alt="image-20241204101011422" style="zoom:33%;" />

<img src=".\assets\image-20241204101025459.png" alt="image-20241204101025459" style="zoom:33%;" />

#### 软件测试过程

软件测试的过程,即软件集成、形成过程

<img src=".\assets\image-20241204101416455.png" alt="image-20241204101416455" style="zoom:30%;" />

测试步骤：

1是单元测试，2和3是集成测试

1. 模块测试：又称单元测试，一般是发现编码和详细设计的错误
2. 子系统测试：侧重测试模块间的接口
3. 系统测试：软件设计和需求说明中的错误
4. 验收测试：确认测试
5. 平行运行：关系重大的软件产品在验收之后往往并不立即投入生产运行，而是要再经过一段平行时间的考验

##### 单元测试

集中对用源代码实现的每一个程序单元进行测试，检查各个程序模块是否正确地实现了规定的功能。 

单元测试又称模块测试，是软件测试的最小单位。 

目的:是发现各模块内部可能存在的各种差错

动态测试，主要采用白盒测试的测试用例，辅之以黑盒测试

由编码程序员进行的测试 

多个模块可以并行地独立进行单元测试

单元测试的内容：

（1）局部数据结构

（2）路径测试

由于不可能穷尽测试，所以在单元测试期间选择最具有代表性、最可能发现错误的执行通路进行测试就是十分关键的

（3）模块接口

![image-20241215231212282](.\assets\image-20241215231212282.png)

（4）错误处理

预见出现错误的条件，并且设置适当的处理错误的通路

（5）边界条件

边界测试是单元测试中最后的也可能是最重要的任务，软件常常在它的边界上失效



单元测试的环境：

模块并不一定是一个独立的程序

辅助模块，模拟与被测模块**相联系的其它模块**

驱动模块：相当于被测模块的**主程序**。它接收测试数据，把这些数据传送给被测模块，最后再输出实测结果

桩模块(stub)：存根模块。用以代替被测模块调用的**子模块**

<img src=".\assets\image-20241204102701993.png" alt="image-20241204102701993" style="zoom:33%;" />

##### 集成测试

把已测试过的模块组装起来，主要对与设计相关的软件体系结构的构造进行测试

主要目标是发现与接口有关的问题

模块组装集成有两种方式： 

- 一次性组装方式 (bigbang)

  它是一种非渐增式组装方式，也叫做整体拼装。 

  使用这种方式，首先对每个模块分别进行模块测试，然后再把所有模块组装在一起进行测试，最终得到要求的软件系统

- 增殖式组装方式

  这种组装方式又称渐增式组装 

  首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统 

  在组装的过程中，一边连接一边测试，以发现连接过程中产生的问题 

  通过增殖方式**逐步组装**成为要求的软件系统

  - 自顶向下集成

    有深度优先和宽度优先两种

    下面是深度优先的例子：

    <img src=".\assets\image-20241204103006476.png" alt="image-20241204103006476" style="zoom:50%;" />

    是存根程序不断被实际模块取代的过程

  - 自底向上集成

    不再需要存根模块

    <img src=".\assets\image-20241204103022617.png" alt="image-20241204103022617" style="zoom:50%;" />
  
    d是测试驱动程序
  
    <img src=".\assets\image-20241204103037106.png" alt="image-20241204103037106" style="zoom:50%;" />
  
    ![image-20241215232949538](.\assets\image-20241215232949538.png)
  
  - 混合策略
  
    <img src=".\assets\image-20241204103118976.png" alt="image-20241204103118976" style="zoom:50%;" />

##### 回归测试

在集成测试的范畴中，回归测试指的是重新执行已经做过的测试的某个子集，以保证之前测试的更改后没有带来非预期的副作用

##### 确认测试

确认测试又叫验收测试，目的是验证软件的有效性

检查已实现的软件是否满足了需求规格说明中确定了的各种需求，以及软件配置是否完全、正确

确认测试又称有效性测试。任务是验证软件的功能和性能及其它特性是否与用户的要求一致

对软件的功能和性能要求在软件需求规格说明书中已经明确规定。包含的信息就是软件确认测试的基础

确认测试必须有用户积极参与，或者以用户为主进行

确认测试通常使用黑盒测试法

主要工作：

###### 有效性测试

黑盒测试

<img src=".\assets\image-20241204132550769.png" alt="image-20241204132550769" style="zoom:33%;" />

###### 软件配置复查

<img src=".\assets\image-20241204132636231.png" alt="image-20241204132636231" style="zoom: 33%;" />

###### α测试

是由用户在开发者的场所，在开发者的指导下进行测试

是在受控的环境中进行的

###### β测试

是由软件的最终用户们在一个或多个客户场所进行，开发者通常不在测试现场

是在开发者无法控制的环境下

只有当α测试达到一定的可靠程度时才能开始β测试

##### 系统测试

把经过确认的软件纳入**实际运行环境**中，与其它系统成份组合在一起进行测试

系统测试的目的在于通过与系统的需求定义作比较,  发现软件与系统的定义不符合或与之矛盾的地方

##### 非功能性测试

<img src=".\assets\image-20241204152350793.png" alt="image-20241204152350793" style="zoom:40%;" />

- 性能测试

  检查软件系统是否满足在需求规格说明中**规定的性能或效率** 

  例如：响应时间、吞吐量，并发操作数、存储规模等

- 强度测试

  不断施加更大的压力和使用强度，来获得**系统能提供的最大服务能力**

- 界面测试

  不断施加更大的压力和使用强度，来获得系统能提供的最大服务能力

- 可靠性测试

  如果系统需求说明书中有**对可靠性的要求**，则需进行可靠性测试

- 安全性测试

  要检验在**系统中已经存在的系统安全性、保密性措施****是否发挥作用，有无漏洞，能否抵御黑客的攻击

- 恢复测试

  证实在**克服硬件故障**(包括掉电、硬件或网络出错等) 后，系统能否正常地继续进行工作，并不对系统造成任何损害

- 配置测试

  检查计算机系统内各个设备或各种资源之间的相互联结和功能分配中的错误

  - 配置命令测试
  - 循环配置测试
  - 修复测试

- 可使用性测试

  主要从使用的**合理性和方便性**等角度对软件系统进行检查，发现人为因素或使用上的问题

- 可支持性测试

  这类测试是要验证系统的支持策略对于公司与用户方面是否切实可行

- 安装测试

  安装测试的目的不是找软件错误，而是找**安装错误**

- 过程测试

  指定由人工完成的过程也需经过仔细的检查，这就是所谓的过程测试

- 兼容性测试

  验证软件产品在不同版本之间的兼容性

  - 向下兼容
  - 交错兼容

- 容量测试

  检验系统的能力最高能达到什么程度

- 文档测试

  检查用户文档(如用户手册)的清晰性和精确

  用户文档中所使用的例子必须在测试中一一试过，确保叙述正确无误

#### 停止测试

考虑因素：

- 测试是预算、时间和质量之间的权衡
- 由盈利模式驱动
- 被动：时间、预算或测试用例已经用尽
- 主动：可靠性已经符合要求，或者继续测试带来的收益低于成本

何时停止：

- ddl已到
- 预算已经用完
- 测试计划已经完成
- 如果已经检测出了x个defect
- 每个defect的平均成本已经达到一定限度
- 如果在过去n天内：
  - 无defect，无bug
  - defect和bug的数量少于x
  - 未发现严重defect

#### 测试中的可靠性

测试阶段的根本目标是消除错误，保证软件的可靠性

软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功运行的概率

上述定义的随机变量是时间间隔，可靠性随着给定的时间间隔的加大而减少

利用测试的统计数据来估算软件的可靠性，以控制软件的质量

测试要素：

<img src=".\assets\image-20241204154940432.png" alt="image-20241204154940432" style="zoom:33%;" />

#### 量化计算

可靠性reliability：程序在**给定的时间间隔**内，按照规格说明书的规定，成功运行的概率

可用性usability：程序在**给定的时间点**，按照规格说明书的规定，成功运行的概率

<img src=".\assets\image-20241204155228280.png" alt="image-20241204155228280" style="zoom:40%;" />

T~up~：正常运行时间  T~down~：系统故障停机时间

MTTF：平均无故障时间   MTTR：平均修复时间

<img src=".\assets\image-20241216113027336.png" alt="image-20241216113027336" style="zoom: 50%;" />

<img src=".\assets\image-20241216113140593.png" alt="image-20241216113140593" style="zoom:50%;" />

<img src=".\assets\image-20241216113212887.png" alt="image-20241216113212887" style="zoom:50%;" />

<img src=".\assets\image-20241216113339814.png" alt="image-20241216113339814" style="zoom:50%;" />

7.6这个公式就是求出了Ec，Ec是改正的错误数，这个公式就是得到了一个停止测试的标准，当改正多少个错误后，可以停止测试

估计E~T~的方法：

- 植入错误法

  基本假定是所用的测试方案发现植入错误和发现原有错误的概率相同

  ![image-20241216221442840](.\assets\image-20241216221442840.png)

<img src=".\assets\微信图片_20241216221151.jpg" style="zoom:20%;" />

- 分别测试法

  植入错误法的假设有时与事实不完全一致，人为植入的错误和程序中原有的错误可能性质很不相同，发现他们的难以程度自然也不同

  改成随机把程序中一部分原有的错误加上标记，然后根据测试过程中的有标记错误和无标记错误的比例，估计程序中的错误总数

<img src=".\assets\image-20241216221930491.png" alt="image-20241216221930491" style="zoom:50%;" />

<img src=".\assets\image-20241216222326467.png" alt="image-20241216222326467" style="zoom:50%;" />



## 第八章 软件维护

### 小题

软件维护定义：在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。

软件运行＝软件维护 

在软件维护中，为增加和改进软件的功能所做的维护占 80%，而为改正错误所做的维护仅占20%。 

统计数据表明：实际上用于软件维护的费用占软件总费用的55-80%。 

软件维护比软件开发更困难，需要更多的创造性工作。 

一般不涉及体系结构的重大变化

软件的变化是不可避免的

维护阶段是软件生命周期的最后一个阶段

结构化维护能够减少精力的浪费并且能提高维护的总体质量



**软件维护的类型：**

- 改正性维护：目的是识别和矫正功能错误、性能错误和实现上的错误
- 适应性维护：使软件适应于外界环境的改变而对软件所做的修改工作。 
- 完善性维护：为了扩充软件的功能或改善软件的性能对软件所做的改变。 
- 预防性维护：为了以后更便于维护，或者为了改进可靠性 ，或者提供更好的基础便于将来提高性能而修改软件。

软件维护绝不仅限于纠正使用中发现的错误，事实上在全部维护活动中一半以上是完善性维护



**维护的成本：**

<img src=".\assets\image-20241216224121626.png" alt="image-20241216224121626" style="zoom:33%;" />

用于维护工作的劳动可以分成生成性活动和非生产性活动



**软件可维护性：**

定义：软件可维护性是指软件被理解、改正、调整和改进的程度

（课件）度量程序可维护性的七个特性：可理解性、可测试性、可修改性、可靠性、可移植性、可使用性、效率

（课本）决定软件可维护性的因素：可理解性、可测试性、可修改性、可移植性、可重用性

文档是影响软件可维护性的决定因素

文档比程序代码更重要

软件系统的文档可以分成用户文档和系统文档两类

- 用户文档：描述系统功能和使用方法，不关心功能如何实现
- 系统文档：描述系统设计、实现和测试



**再工程：**

<img src=".\assets\image-20241216231922403.png" alt="image-20241216231922403" style="zoom:50%;" />

### 大题

##### 维护过程

1. 维护组织
2. 维护报告：维护要求表是外部产生的文件（用户写的），软件修改报告是内部制定的
3. 维护的工作流程：为维护规定一个标准化的事件序列
4. 维护记录
5. 维护评价



##### 可维护性因素与措施

<img src=".\assets\image-20241216232024711.png" alt="image-20241216232024711" style="zoom:50%;" />



## 第九章 软件项目管理

### 小题

项目是指为创建一个唯一的产品，或者提供唯一的服务而进行的努力活动

项目的特点：目标性、周期性、约束性、不确定性

软件开发是一项错综复杂关系的工作，沟通与交流的工作量极大。

Brooks法则：向一个进度延迟的软件项目中增加人员可能会使其进度更加推迟



**人员匹配数量：**

<img src=".\assets\image-20241216234314713.png" alt="image-20241216234314713" style="zoom:33%;" />

需要的人力随开发进展逐渐增加，在编码与单元测试阶段达到高峰，以后又逐渐减少

恒定地配备人力将浪费人力资源



**软件开发团队组织：**

- 主程序员式组织结构：**以主程序员为核心**，主程序员既是项目管理者也是技术负责人，团队其他人员的职能进行专业化分工

  重要特性：专业化、层次性

- 矩阵式组织结构：**将技术与管理工作进行分离**，技术负责人负责技术决策， 管理负责人负责非技术性事务的管理决策和绩效评价



**软件配置：**

软件配置项SCI是为了配置管理而作为单独实体处理的一个工作产品或软件

<img src=".\assets\image-20241216234747042.png" alt="image-20241216234747042" style="zoom: 45%;" />

软件配置管理是在**软件的整个生命期内**，管理变化的一组活动。**在软件项目启动时就开始，并且一直持续到软件退役才终止**的一组跟踪和控制活动。

基线Baseline是已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变。基线中的配置项被“冻结”了，则不能再被任何人随意修改

基线标志着软件开发过程的各个**里程碑**（Milestone）

一个产品可以有多个基线，也可以只有一个基线

### 大题

##### 配置管理过程

1. 标识配置项
2. 进行配置控制（关键核心）
3. 执行配置审计
4. 记录配置状态



##### CMM

Capability  Maturity  Model  for Software软件能力成熟度模型

CMM是用于衡量软件过程能力的事实上的标准，同时也是目前软件过程改进最好的参考标准。

过程成熟度（ Process Mature ） 一个特定软件过程被明确和有效地定义、管理、测量和控制的程度

成熟度级别定义了在使软件过程成熟的过程中的演化状态。

CMM只定义5个等级，引导软件开发机构识别出缺陷，指出应该做哪些改进，但是它并不提供做这些改进的具体措施

CMM五个级别：

<img src=".\assets\image-20241216235448334.png" alt="image-20241216235448334" style="zoom:35%;" />

初始级：过程能力**不可预测**。软件过程是不稳定的。没有提供开发和维护软件的稳定的环境。当发生危机时，项目通常放弃计划的过程，回复到编码和测试。产品质量只能根据相关人员的个人工作能力而不是软件机构的过程能力来预测。

可重复级：过程能力是**严格**的。配备了基本的软件管理控制。将软件项目的有效管理过程制度化，这使得组织能够重复以前项目中的成功实践。

已定义级：过程能力是**标准和一致**的。已经定义了完整的软件过程（过程模型），软件过程已经文档化和标准化。

已管理级：过程能力是**可预言**的。为软件产品和过程都设定了量化的质量目标。软件过程在可度量的范围内运行。

持续优化级：过程能力是**持续改善**的。集中精力持续不断的改进软件过程。软件过程被评价（分析确定产生某一缺陷的原因），以防止过失重复发生，从中获得的教训散布给其它项目。



### 设计题

#### 甘特图

横轴表示时间，纵轴表示活动(项目)，线条表示在整个期间上计划和实际的活动完成情况

![image-20241217093703349](.\assets\image-20241217093703349.png)

<img src=".\assets\image-20241217093642999.png" alt="image-20241217093642999" style="zoom:50%;" />

<img src=".\assets\微信图片_20241217093614.jpg" style="zoom:50%;" />

其实有错误，课本后面也写了，第2面墙刷新漆没有在刮完旧漆之后进行，正确的图应该是从第二阶段蓝色开始都错后一格，总时间是23小时而不是22小时

甘特图缺点：

(1)不能显式地描绘各项作业彼此间的依赖关系；

 (2)进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象；

 (3)计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费

#### 工程网络图

显式描绘依赖关系

工程网络中用箭头表示作业，用圆圈表示事件（一项作业开始或结束）

注意，事件是时间点，不消耗时间和资源；作业通常既消耗资源又需要持续一定时间

<img src=".\assets\image-20241217094906868.png" alt="image-20241217094906868" style="zoom:50%;" />

<img src=".\assets\image-20241217094918433.png" alt="image-20241217094918433" style="zoom:50%;" />

<img src=".\assets\image-20241217094929918.png" alt="image-20241217094929918" style="zoom:50%;" />

<img src=".\assets\微信图片_20241217094730.jpg" style="zoom:50%;" />

<img src=".\assets\image-20241217101424102.png" alt="image-20241217101424102" style="zoom:50%;" />

机动时间在箭头下方的括号里

<img src=".\assets\微信图片_20241217100820.jpg" style="zoom:50%;" />

<img src=".\assets\image-20241217103153974.png" alt="image-20241217103153974" style="zoom:50%;" />





