## 设计题（50）

1. 数据流图，数据字典

2. UML建模

   功能模型：用例图（参与者+系统，系统要加框。参与者之间关系是泛化；用例之间是include和extend；参与者与用例之间是关联）

   对象模型（静态模型）：类图【对象模型是最基本最重要的，为其他两种模型奠定基础】

   （框里只写类名，不用画属性和操作，关系有关联、泛化、实现和依赖四种，关联有一般关联、聚合、组合）

   行为模型（动态模型）：顺序图和状态图

3. 总体结构设计

   由DFD图导出总体结构

   由DFD导出IPO图

4. 详细设计工具

   程序流程图，盒图，PAD图，判断表，判定树，伪代码

5. 白盒测试

   语句覆盖，判定覆盖，条件覆盖，判定/条件覆盖，条件组合覆盖，路径覆盖，点覆盖，边覆盖

6. 黑盒测试

   等价类划分（应该是考这个），边界测试，错误推测法，因果图法

7. 甘特图

8. 工程网络图

9. 用户故事和敏捷开发（zjq）



## 简答题（30）

说答案不要理解性，要精准性，背诵

1. 什么是软件工程

   软件工程是采用**工程**的**观念、原理、技术和方法**来**开发与维护**软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以**经济地开发**出高质量的软件并**有效地维护**它，这就是软件工程

2. 软件工程与计算机科学的区别

   科学→发现世界上已经存在的事物

   工程→创造世界上从未存在的事物

3. 什么是软件危机

   软件危机是指在计算机软件的**开发**和**维护**过程中所遇到的一系列**严重问题**。

   两方面问题： 

   - 如何**开发**软件，以**满足**不断增长、日趋复杂的**需求**。 （**开发**）  
   - 如何**维护**数量不断膨胀的软件**产品**。 （**维护**）

4. 软件危机的具体表现

   成本和进度估计不准确，用户不满意，质量出现问题，不可维护，缺少文档资料，跟不上计算机发展趋势

5. 软件危机出现的原因

   逻辑部件，规模庞大，周期漫长，错误方法技术，没有完整准确认识用户需求，不同阶段不同的修改代价，轻视维护

6. 软件固有的内在特性

   复杂度、一致性、可变性、不可见性

7. 软件由什么组成

   软件=程序+数据+文档

   程序是指令序列，数据是数据+数据结构，文档是图文资料

8. 文档的作用

   记录，参照，交流工具，便于管理，便于维护，阶段性成果，软件质量保障

9. 程序有哪些形式

   面向机器的程序=二进制代码

   面向过程的程序=算法+数据结构

   面向对象的程序=对象+消息

   面向组件的程序=组件+基础设施

10. 软件过程理论模型有哪些（来自课件,课本无）

    线性顺序过程模型，循环过程模型，增量过程模型，螺旋过程模型，并行过程模型，基于组件的模型，形式化变换模型

11. 瀑布模型

    **缺点（考的可能性较大）：**顺序性和依赖性，推迟实现，文档驱动，不能并行，过程不可逆转，错误放大，在最后阶段才能出现，不满足需求

    优点：经典，容易管理，有文档

    适用场景：需求明确，需求不变，面向结构方法

12. 快速原型模型

    缺点：没有明确的阶段划分，难以管理

    优点：适应需求变化，开发周期短，开发成本低

    适用场景：需求有但不明确，开发者不确定算法的有效性，人机交互

13. 增量模型：

    缺点：管理多版本的复杂性

    优点：早期交付部分功能，循序渐进

    适用场景：大型项目，长期项目，需求稳定但复杂

14. 螺旋模型

    缺点：复杂性高，对风险分析依赖大

    优点：风险管理好，成本可控

    适用场景：高风险项目，需求易变，大型复杂系统

15. 敏捷模型

    个体和交互胜过过程和工具

    可以工作的软件胜过面面俱到的文档

    客户合作胜过合同谈判（能够满足客户不断变化的需求）

    响应变化胜过遵循计划

    适用场景：资源和时间都有严格约束的小型项目

16. 敏捷开发的定义

    敏捷开发是一种基于**更紧密的团队协作**、能够**有效应对快速变化需求**、**快速交付高质量软件**的**迭代和增量**的**新型软件开发方法**。

17. 敏捷核心理念

    聚焦客户价值

    激发团队潜能

    不断调整以适应变化

18. 各种软件过程模型的比较：

    瀑布模型和其他比的话，就是顺序性+需求不可改变，其他模型都是迭代+响应需求变化

    快速原型是需求不明确，会变化，增量是需求稳定但复杂

    快速原型模型的区别是用户参与，没有明确阶段划分

    适用场景不同，瀑布是需求不变，快速原型是需求不明确，增量是大型项目，螺旋是风险项目，敏捷是小项目

19. 软件生命周期的三个时期，八个阶段

    八个阶段是问题定义，可行性分析，需求分析，总体设计，详细设计，编码，测试，运行维护

    三个时期是软件定义123，软件开发4567，软件维护8

20. 可行性分析的目的

    用**最小的代价**在**尽可能短的时间**内确定**问题是否可解**，同时确定**问题是否值得去解决**

21. 可行性分析的方面

    **技术**可行性：**技术**分析、资料分析、**风险**分析、困难性

    **经济**可行性：**成本/效益**分析、价值和成本的关系

    **运营**可行性：**用户**使用可能性、时间进度可行性、组织和人事可行性、文化上的可行性

    **社会**可行性：开发项目是否会在**社会**上或**政治**上引起侵权、隐私、破坏或其他责任问题。

22. 软件需求有哪些方面（软件需求规格说明书的内容也是答这个）（SRS的目录结构）

    可以分成功能需求和非功能需求

    非功能需求可以展开成可靠性和可用性需求、约束性需求、出错处理需求、接口需求、逆向需求、将来可能提出的要求

    （软件需求规格说明书通常用自然语言描述上述需求，为了消除自然语言书写带来的歧义可以采用形式化语言）

23. 向用户获取需求的方法

    访谈，讲述，观点，录像机，调研问卷，网络搜索，网上需求社区

    在访问用户的过程中使用情景分析技术往往十分有效

24. 针对特定的情境如何获取用户需求

    访谈：同一时间同一地点，人少，工作人员驱动

    调研问卷：不同时间不同地点，人多，工作人员提供问卷

    团体调查：相同时间，相同或不同地点，20人，工作人员协助（大家一起分享看法，效果比一个人好）

    观察：同一时间同一地点，工作人员观察

25. 需求分析有哪些方面

    需求分析分为面向结构分析和面向对象分析

    面向结构分析有数据流模型、数据字典和实体关系模型

    面向对象分析有对象模型、功能模型和动态模型

26. 结构程序设计的定义

    结构程序设计是一种设计程序的技术，它采用**自顶向下，逐步求精**的设计方法，以及**单入口单出口**的控制结构

27. 模块设计原理

    模块化，把程序划分成若干个模块，每个模块完成一个子功能

    抽象，抽出事物的本质特性，而暂时不考虑它们的细节

    逐步求精，集中精力解决主要问题而尽量推迟对问题细节的考虑（事件按优先顺序排序完成）

    信息隐蔽和局部化，模块中所包含的信息不允许其它不需要这些信息的模块使用，局部化是把关系密切的软件元素在物理上放得近

    模块独立，实现高内聚低耦合

    （模块独立是模块化、抽象、信息隐蔽和局部化的直接结果）

28. 模块设计原理的每个内容如果问好处

    提高软件可靠性，可理解性，可测试性，可维护性

29. 模块设计启发式规则

    改进软件结构提高**模块独立性**

    **模块规模**应该适中

    **深度宽度扇出扇入**都要适当

    模块的**作用域应该在控制域之内**

    力争降低**模块接口**的复杂程度（传递的参数）

    设计**单入口单出口**的模块

    模块**功能可预测**（只要输入的数据相同就产生同样的输出）

30. 什么是软件体系结构

     软件体系结构定义了软件局部和总体计算部件的**构成**

    软件体系结构定义了组成部件之间的相互作用**关系**

    软件体系结构定义了构成系统的合成原理、方法、**原则**

    软件体系结构定义了构成系统应该遵守的约束的**条件**

31. 广泛提及的体系结构风格有哪些，请举例

    分布式对象体系结构：基本系统组件是对象，对象之间不存在客户机与服务器的界限。例如.NET体系

    客户/服务器体系结构：服务器提供服务，客户端请求并使用这些服务

    层次体系结构：系统被分解为逻辑层，每层执行特定的功能，并且通常层与层之间存在依赖关系（计算机网络模型）

    管道和过滤器：组件（过滤器）通过管道顺序连接，每个过滤器执行特定的任务，并且输出作为下一个过滤器的输入

32. 软件设计方法有哪些

    结构化设计方法(SD)

    面向对象的设计方法(OOD) 

    面向数据结构的设计方法(JSD方法)

33. 程序复杂性度量方法

    代码行度量法

    McCabe度量法

    Halstead的软科学法

34. 软件测试的定义

    软件测试是为了发现错误而运行一个软件的过程

35. 有效和验证的区别

    有效是“是否开发了正确的产品”，软件需要实现用户需要的功能，是客观评价

    验证是“是否正确开发了产品”，软件应符合规范，是主观评价

36. 程序测试和软件测试的区别

    软件测试应贯穿于软件定义与开发的整个期间

    软件测试中发现的错误仅有少部分属于程序错误

37. 软件测试方法

    分为静态测试和动态测试

    静态测试是需求规格说明书、软件设计说明书、源程序做检查和审阅，不实际运行被测试的软件

    动态测试分为白盒测试和黑盒测试，白盒测试是内部的结构测试，黑盒测试是外部的功能测试

38. 软件测试分为哪几个阶段

    单元测试，检查各个程序模块是否正确地实现了规定的功能

    集成测试，把已测试过的模块组装起来，主要目标是发现与接口有关的问题

    回归测试，重新执行已经做过的测试的某个子集，以保证之前测试的更改后没有带来非预期的副作用

    确认测试，验证软件的功能和性能及其它特性是否与用户的要求一致

    系统测试，把经过确认的软件纳入实际运行环境中，与其它系统成份组合在一起进行测试

39. 增殖式组装方式中的自顶向下集成和自底向上集成有什么区别

    自顶向下集成不需要驱动程序，能够在测试早期实现并验证系统的主要功能并发现上层接口错误；需要存根程序，可能遇到与此相联系的测试困难，底层关键模块中的错误发现较晚，早期不能充分展开人力

    自底向上集成与其完全相反，需要驱动，不需要存根，优点就是其缺点，缺点就是其优点

    为了解决，可以采用混合策略，首先对输入输出模块和关键算法模块进行测试，再自底向上组装成为功能独立的子系统，然后由子模块开始自顶向下进行增殖测试

40. 确认测试阶段的主要工作有哪些

    有效性测试，用黑盒测试方法测试功能是否满足需求

    软件配置复查

    α测试，由用户在开发者的场所，在开发者的指导下进行测试

    β测试，软件的最终用户们在一个或多个客户场所进行，开发者通常不在测试现场

41. 停止测试的考虑因素

    测试是预算、时间和质量之间的权衡，由盈利模式驱动

    被动：时间、预算或测试用例已经用尽

    主动：可靠性已经符合要求，或者继续测试带来的收益低于成本

42. 软件调试的方法

    强行排错法，每个位置打印语句来寻找出错位置

    回溯法调试，在发现错误的位置回溯源程序代码，直至找到错误根源

    归纳法调试，从一些错误征兆着手，通过分析它们之间的关系来找出错误

    演绎法调试，以所有可能出错的原因作为假设，从中逐个排除不可能正确的假设

    对分查找法，对错误原因的位置逐次二分定位

    （后三个都属于原因排除法）

43. 什么是软件可靠性

    软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功运行的概率

    上述定义的随机变量是时间间隔，可靠性随着给定的时间间隔的加大而减少

44. 软件可靠性和可用性的区别

    可靠性是程序在**给定的时间间隔**内，按照规格说明书的规定，成功运行的概率

    可用性是程序在**给定的时间点**，按照规格说明书的规定，成功运行的概率

45. 软件维护的原因

    系统不断变化，需求也不断变化

    软件错误需要修正

    扩展功能需要添加

46. 软件维护的类型

    改正性维护：目的是识别和矫正功能错误、性能错误和实现上的错误（改正错误）

    适应性维护：使软件适应于外界环境的改变而对软件所做的修改工作（适应环境）

    完善性维护：为了扩充软件的功能或改善软件的性能对软件所做的改变（完善性能）

    预防性维护：为了以后更便于维护，或者为了改进可靠性 ，或者提供更好的基础便于将来提高性能而修改软件（预防以后）

47. 决定软件可维护性的因素（如果问哪三个因素，必须写前三个，网络上主要因素是前三个，课本上是五个，主要因素没有可靠性）

    **可理解性、可测试性、可修改性**、可移植性、可重用性

48. 软件重用的效益

    产品质量，开发生产率和整体成本都得到了改善

49. 在软件开发过程中，人员配置数量应该如何变化

    需要的人力随开发进展逐渐增加，在编码与单元测试阶段达到高峰，以后又逐渐减少

    恒定地配备人力将浪费人力资源

50. 软件配置管理中的基线是什么

    基线Baseline是已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变。基线中的配置项被“冻结”了，则不能再被任何人随意修改

    基线标志着软件开发过程的各个**里程碑**

51. 估算软件规模的方法有哪些

    代码行技术，估计实现一个功能所需要的源程序行数

    功能点技术，用功能点为单位度量

52. CMM软件能力成熟度模型的五个等级

    初始级：过程能力**不可预测**。软件过程是不稳定的。**没有**提供开发和维护软件的稳定的环境。当发生危机时，项目通常放弃计划的过程，回复到编码和测试。产品质量只能根据相关人员的个人工作能力而不是软件机构的过程能力来预测

    可重复级：过程能力是**严格**的。配备了**基本**的软件管理控制。将软件项目的有效管理过程制度化，这使得组织能够重复以前项目中的成功实践

    已定义级：过程能力是**标准和一致**的。已经定义了**完整**的软件过程（过程模型），软件过程已经文档化和标准化

    已管理级：过程能力是**可预言**的。为软件产品和过程都设定了**量化**的质量目标。软件过程在可度量的范围内运行

    持续优化级：过程能力是**持续改善**的。集中精力持续不断的**改进**软件过程。软件过程被**评价**（分析确定产生某一缺陷的原因），以防止过失重复发生，从中获得的教训散布给其它项目

    



## 判断题（10）

说满分不容易

1. 几乎所有软件都不同程度的存在软件危机
2. 软件工程的出现是为了解决软件危机
3. 编写程序所需工作量只占软件开发全部工作量的10%~20%
4. 维护是极端艰巨复杂的工作，需要花费很大代价。用于软件维护的费用占软件总费用的55%~70%
5. 在软件生命周期的每个阶段都要得出最终产品的一个或几个组成部分
6. 软件就是程序是错误的观念
7. 大部分错误时是在编码之前造成的
8. 原型模型从需求收集开始。**开发者和用户一起**定义软件的总体目标，标识出已知的需求，并规划出进一步定义的区域
9. 敏捷模型只是更重视一方，另一方不是不重要，更不能被取代
10. 敏捷模型不是一种正式严谨的方法
11. 开发小组的人员应该“少而精”，少是因为随着开发小组人员数目的增加，因为交流情况讨论问题而造成的通信开销急剧增加
12. 20%的代码有80%的错误
13. 20%的人解决了80%的问题
14. 80%的信息功能需要20%的投资
15. 错误发现与改正的越晚，所需付出的代价就越高
16. 可行性研究的目的不是解决问题，而是确定是否可解，是否值得去解决
17. 任何一个软件系统本质上都是信息处理系统
18. 数据存储和数据流都是数据，仅仅所处的状态不同。数据存储是处于静止状态的数据，数据流是处于运动中的数据。
19. 只有同时使用对象、类、继承和消息的方法，才是真正的面向对象的方法
20. 面向对象的设计方法与传统的面向过程方法有本质不同，强调模拟现实世界中的概念而不强调算法，**计算机的观点是不重要的**
21. 软件工程过程的每一步，都是对软件解法的抽象层次的一次细化。最后，当源程序写出来时， 也就达到了**抽象的最低层**。
22. 软件设计的最小单元是模块
23. 详细设计阶段的任务还**不是具体地编写程序**，而是要设计出程序的“蓝图”，程序员根据这个蓝图写出实际的程序代码。
24. PAD符号所设计出的程序**必然是结构化程序**。 
25. 软件测试在软件生命周期中横跨两个阶段。因为编写出模块后要做单元测试，测试阶段要做综合测试
26. 程序复杂度度量是程序的复杂度，而不是一个算法的复杂度
27. 软件测试是为了发现错误而运行一个软件的过程
28. 测试是为了发现程序中的错误而执行程序的过程 
29. 一个好的测试用例是发现了至今未发现错误的用例 
30. 一次成功的测试是发现了至今未发现错误的测试 
31. 程序测试能证明错误的存在, **但不能证明错误不存在**
32. 测试只能证明程序中有错误，不能证明程序中没有错误。但是，精心的设计测试方案，有可能充分覆盖程序逻辑并使程序达到所要求的可靠性
33. 测试的目的是发现程序中的错误，为了证明程序有错, **而不是证明程序无错**。
34. 把证明程序无错当作测试目的不仅是不正确的, 完全做不到的，而且对做好测试没有任何益处，甚至是十分有害的（因为以证明程序正确为目标，就会设计一些不易暴露错误的测试方案，只有以发现错误为目标，才会力求设计出最能暴露错误的方案）
35. 软件测试要设法使软件发生故障, 暴露软件错误
36. 测试的“成功”与“失败” ：能够发现错误的测试是成功的测试，否则是失败的测试
37. “测试的目的是说明程序正确地执行它应有的功能” 这种说法不正确
38. 测试绝不能证明程序是正确的
39. 为了达到最佳的测试效果，应该由独立的第三方从事测试工作(通常他们主要承担模块测试工作)
40. 软件调试是在进行了成功的测试之后才开始的工作
41. 应该远在测试开始之前就制定出测试计划
42. 穷举测试是不可能的。但是,精心地设计测试方案,有可能充分覆盖程序逻辑并使程序达到所要求的可靠性
43. 条件覆盖不一定包含判定覆盖，判定覆盖也不一定包含条件覆盖
44. 满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到
45. 满足条件组合覆盖标准的测试数据，也一定满足判定覆盖、条件覆盖和判定/条件覆盖标准
46. 在软件测试的后期阶段进行黑盒测试
47. 边界测试不是从某等价类中随便挑一个作为代表，而是每个边界都要作为测试条件
48. 测试边界上的合法数据,以及刚超过边界的非法数据
49. 确认测试必须有用户积极参与，或者以用户为主进行
50. α测试是用户在开发者的场所，在开发者的指导下进行测试，是在受控的环境中进行的。β测试是由软件的最终用户们在一个或多个客户场所进行，开发者通常不在测试现场，是在开发者无法控制的环境下
51. 只有当α测试达到一定的可靠程度时才能开始β测试
52. 软件维护发生在软件已经交付使用之后
53. 软件维护绝不仅限于纠正使用中发现的错误，事实上在全部维护活动中一半以上是**完善性维护**
54. 软件运行＝软件维护
55. 在软件维护中，为增加和改进软件的功能所做的维护占 80%，而为改正错误所做的维护仅占20%
56. 统计数据表明：实际上用于软件维护的费用占软件总费用的55-80%
57. 软件维护比软件开发更困难，需要更多的创造性工作
58. 维护阶段是软件生命周期的最后一个阶段
59. 文档比程序代码更重要
60. Brooks法则：向一个进度延迟的软件项目中增加人员可能会使其进度更加推迟
61. 软件配置管理是在**软件的整个生命期内**，管理变化的一组活动。**在软件项目启动时就开始，并且一直持续到软件退役才终止**的一组跟踪和控制活动
62. 一个产品可以有多个基线，也可以只有一个基线
63. 功能点数从直接度量软件信息域和评估软件复杂性的经验量化关系中获得
64. CMM只定义5个等级，引导软件开发机构识别出缺陷，指出应该做哪些改进，但是它**并不提供**做这些改进的**具体措施**



## 单选题（10）

说考的是概念性题目

1. 软件工程包括**技术**和**管理**两方面的内容。

2. 软件工程方法学包括三要素：**方法、工具和过程**

3. 在软件生命周期的每个阶段都要得出最终产品的一个或几个组成部分，这些组成部分通常以**文档资料**的形式存在

4. **做好软件定义时期的工作**，是降低软件成本提高软件质量的关键

5. 开发软件的目的是**支持用户的工作**，因此仅仅用正确的方法构造系统还不够，还必须**构造出正确的系统**

6. 软件过程模型

   瀑布模型：文档驱动，基本对应8个阶段，顺序性，需求已知，优点是有文档，缺点是只依赖文档最后的产品不一定能满足用户需求

   快速原型模型：需求驱动，快速设计，反复迭代，需求已知作为原型，逐步调整原型使其满足客户的要求

   增量模型：迭代，多版本，每一个增量都发布一个产品，第一个增量是**核心产品**，要求软件具有开放结构

   螺旋模型：风险驱动，迭代，每个阶段前都增加了风险分析过程的快速原型模型，优点是风险评估，缺点是风险难以评估

   喷泉模型：面向对象，无缝迭代，阶段内和阶段间的迭代

   敏捷模型：重视人而非工具，重视产品而非文档，重视合作而非谈判，重视变化而非计划

7. 敏捷开发更关注协作、质量、可工作的产品、全才化的专才，基于实践而非基于理论

8. 敏捷开发最有影响的两个方法是**极限编程（XP）**和**Scrum开发方法**

   XP偏重**编程实践**，Scrum偏重**项目管理**

9. 需求分析分为**面向结构分析**和**面向对象分析**

10. 面向结构分析有**数据流模型**、**数据字典**和**实体关系模型**

11. 面向对象分析有**对象模型**、**功能模型**和**动态模型**

12. **访谈**是最早开始使用的获取用户需求的技术

13. **软件需求**是整个软件项目的**终极目标**

14. **软件需求**是后续软件开发活动（设计、编码和测试）的主要基础

15. 需求分析阶段最重要的技术文档是**需求规格说明书**

16. 需求分析的四个步骤中，撰写《需求规格说明书》是在**需求描述**阶段

17. 功能需求是输入 - 输出关系，使用的什么算法是非功能需求

18. 数据字典中，由数据元素组成数据的方式有**顺序（与）、选择（或）、重复和可选**

19. 用例之间的关系有**包含、扩展、泛化**三种

20. **实体关系图**是数据库概念设计的最常用工具

21. 软件设计包括**总体设计**和**详细设计**，总体设计是划分模块，详细设计是模块内部的算法和数据结构

22. 模块独立程度的衡量标准是**耦合性**和**内聚性**

    耦合性：对一个软件结构内**不同模块间**互连程度的度量

    耦合程度由好到坏，模块独立性逐级降低：

    无直接耦合：无直接联系，只通过主模块实现联系

    数据耦合：传递的参数仅是数据

    控制耦合：传递的参数控制分支

    公共耦合：引用同一个公共数据区

    内容耦合：直接访问内部信息，模块代码重叠、多入口模块

    **内容耦合**是最不好的耦合形式

    **尽量使用数据耦合 少用控制耦合 限制公共耦合的范围 坚决避免使用内容耦合**

    内聚性：标志**一个模块内**各个处理元素彼此结合的紧密程度

    内聚程度由弱到强，模块独立性逐级升高：

    偶然内聚：模块内各部分间无联系

    逻辑内聚：逻辑上相似的功能组合在一模块内，每次调用由控制模块的参数确定执行哪种具体功能

    时间内聚：模块内功能只因时间因素关联在一起，是同一时间执行

    过程内聚：有数据依赖顺序关系，必须按次序执行

    通信内聚：模块内各部分使用相同的输入数据，或产生相同的输出结果

    功能内聚：模块所有成分共同完成一个功能，缺一不可 

    **功能内聚**是最高程度的内聚

    **优先使用功能内聚 尽量满足过程内聚 少用逻辑内聚 坚决避免偶然内聚**

23. 模块的作用域应该在控制域之内

    模块的作用域：是指受该模块判定影响的所有模块数。 

    模块的控制域：是受这个模块**直接或间接**控制调用的模块数。 

    模块的控制范围：本身及其所有下级模块。 （图中看出，不止下一级，是整个子树）

    模块的作用范围：即直接调用的模块。（图中看不出，题目给出）

24. 软件定义阶段定义了问题结构，叫作软件设计的**一级蓝图**。 

    软件总体设计确定了软件结构，即确定模块的划分、模块间的接口。可称作软件设计的**二级蓝图**。

    软件详细设计确定每个软件模块的实现算法，可称软件设计的**三级蓝图**。

25. 程序流程图使用三种基本控制结构是**顺序、选择、循环**

26. PAD图中的**竖线的总条数**就是**程序的层次数**

27. 通常把**编码**和**测试**统称为**实现**

28. 注释分为**序言性注释**和**功能性注释**

29. McCabe度量法

    如果有程序流程图，判定节点（菱形）数+1

    如果只有抽象出的程序图，首尾相连，V(G)＝m－n＋p，m是弧数（虚线也算），结点数n，极大连通子图p＝1

    环路复杂度是可加的。例如，模块A的复杂度为3，模块B 的复杂度为 4，则模块A与模块B的复杂度是7。

30. Halstead的软科学法

    N1为实际出现的**运算符总次数**，N2为实际出现的**操作数总次数**

    n1为**不同运算符的个数**，n2为**不同操作数的个数**

    Halstead程序长度N定义为: N = N1 + N2

    Halstead程序长度的预测值：H=n1log~2~n1 + n2log~2~n2

31. 面向结构的精髓：**自顶向下，逐步求精，单入口单出口**

    结构程序设计是一种设计程序的技术，它采用**自顶向下，逐步求精**的设计方法，以及**单入口单出口**的控制结构（面向数据流）

32. 单元测试**模块的编写者和测试者是同一个人**，综合测试通常由**专门的测试人员**承担

33. 调试的任务是**进一步诊断和改正程序中潜在的错误** 

34. 从用户的角度看,最严重的错误是**导致程序不能满足用户需求的那些错误**

35. **单元测试**是软件测试的最小单位

36. 测试阶段的根本目标是**消除错误，保证软件的可靠性**

37. **结构化维护**能够减少精力的浪费并且能提高维护的总体质量

38. **文档**是影响软件可维护性的决定因素

39. 软件系统的文档可以分成**用户文档**（不关心功能如何实现）和**系统文档**（描述系统设计实现和测试）两类

40. 估算平均无故障时间MTTF

41. 估算测试之前程序中的错误总数

42. 主程序员式组织结构：**以主程序员为核心**，矩阵式组织结构：**将技术与管理工作进行分离**

43. 成熟度级别定义了在使软件过程成熟的过程中的**演化状态**
